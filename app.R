# Merged PRRSV Neutralization Predictor: Single-Gene and Multi-Gene Models

pacman::p_load(
  shiny, shinythemes, shinyWidgets, shinyjs, DT,
  rpart, caTools, caret, randomForest, ape, seqinr,
  adegenet, data.table, bioseq, janitor, tidyverse, Biostrings, readr,
  shinycssloaders, DECIPHER, tibble, stringr, ggplot2, lightgbm, pwalign
)

# --- Constants ---
# Gene extraction positions (1-based, for 3188 nt sequences) - MULTI-GENE
gene_positions <- list(
  orf2 = c(1, 771),
  orf3 = c(624, 1388),
  orf4 = c(1169, 1705),
  orf5 = c(1716, 2318),
  orf6 = c(2303, 2827),
  orf7 = c(2817, 3188)
)

# ===== PASTE VACCINE 3188 NT SEQUENCES HERE (from multi-gene doc) =====
vaccine_full_nt_seqs <- list(
  Fostera = "ATGAAATGGGGTCTATACAAAGCCTCTTCGACAAAATTGGCCAGCTTTTTGTGGATGCTTTCACGGAATTTTTGGTGTCCATTGTTGATATCATCATATTTTTGGCCATTTTGTTTGGCTTCACCATCGCCGGTTGGCTGGTGGTCTTTTGCATCAGATTGGTTTGCTCCGCGGTATTCCGTGCGCGCCCTGCCATTCACCCTGAGCAATTACAGAAGATCCTATGAGGCCTTTCTTTCTCAGTGCCGGGTGGACATTCCCACCTGGGGGGTAAAACACCCTTTGGGGATGTTTTGGCACCATAAGGTGTCAACCCTGATTGATGAAATGGTGTCGCGTCGAATGTACCGCATCATGGAAAAAGCAGGGCAAGCTGCCTGGAAACAGGTGGTGAGCGAGGCTACGCTGTCTCGCATTAGTAGTTTGGATGTGGTGGCTCATTTTCAACATCTTGCCGCCATTGAAGCCGAGACCTGTAAATATTTGGCTTCTCGACTGCCCATGCTACACAACCTGCGCATGACAGGGTCAAATGTAACCATAGTGTATAATAGCACTTTAAATCAGGTGTTTGCTATTTTTCCAACCCCTGGTTCCCGGCCAAAGCTTCATGATTTTCAGCAATGGCTAATAGCTGTACATTCCTCCATATTTTCCTCTGTTGCAGCTTCTTGTACTCTTTTTGTTGTGCTGTGGTTGCGGGTTCCAATGCTACGTACTGTTTTTGGTTTCCGCTGGTTAGGGGCAATTTTTCTTTCGAACTCATGGTGAATTACACGGTGTGTCCACCTTGCCTCACCCGACAAGCAGCCGCTGAGGTCCTTGAACCCGGTAGGTCTCTTTGGTGCAGGATAGGGCATGACCGATGTGGGGAGGACGATCACGACGAACTAGGGTTCATGGTTCCGCCTGGCCTCTCCAGCGAAAGCCACTTGACCAGTGTTTACGCCTGGTTGGCGTTCCTGTCCTTCAGCTACACGGCCCAGTTCCATCCCGAGATATTTGGGATAGGGAACGTGAGTGAAGTTTATGTTGACATCAAGCACCAATTCATCTGCGCCGTTCATGACGGGCAGAACACCACCTTGCCTCGCCATGACAATATTTCAGCCGTATTTCAGACCTACTATCAACATCAGGTCGACGGCGGCAATTGGTTTCACCTAGAATGGCTGCGTCCCTTCTTTTCCTCTTGGTTGGTTTTAAATGTTTCGTGGTTTCTCAGGCGTTCGCCTGCAAGCCATGTTTCAGTTCGAGTCTTTCAGACATCAAAACCAACACTACCGCAGCATCAGGCTTTGTTGTCCTCCAGGACATCAGCTGCCTTAGGCATGGCGACTCGTCCTTTCCGACGATTCGCAAAAGCTCTCAATGCCGCACGGCGATAGGGACACCCGTGTATATCACCATCACAGCCAATGTGACAGATGAGAATTACTTACATTCTTCTGATCTCCTCATGCTTTCTTCTTGCCTTTTCTATGCTTCTGAGATGAGTGAAAAGGGATTCAAGGTGGTGTTTGGCAATGTGTCAGGCATCGTGGCTGTGTGTGTCAACTTTACCAGCTACGTCCAACATGTCAAAGAGTTTACCCAACGCTCCTTGGTGGTCGATCATGTGCGGCTGCTTCATTTCATGACACCTGAGACCATGAGGTGGGCAACCGTTTTAGCCTGTCTTTTTGCCATCCTACTGGCAATTTGAATGTTCAAGTATGTTGGGGAAATGCTTGACCGCGGGCTGTTGCTCGCGATTGCTTTCTTTGTGGTGTATCGTGCCGTTCTGTTTTGCTGTGCTCGGCAGCGCCAACAGCAGCAGCAGCTCTCATTTTCAGTTGATTTATAACTTGACGCTATGTGAGCTGAATGGCACAGATTGGCTGGCAGAAAAATTTGATTGGGCAGTGGAGACTTTTGTCATCTTTCCCGTGTTGACTCACATTGTTTCCTATGGTGCACTCACCACCAGCCATTTCCTTGACACAGTTGGTCTGGTTACTGTGTCCACCGCCGGGTTTTATCACGGGCGGTATGTCTTGAGTAGCATCTACGCGGTCTGTGCTCTGGCTGCGTTGATTTGCTTCGTTATTAGGCTTGCGAAGAACTGCATGTCCTGGCGCTACTCTTGTACCAGATATACCAACTTCCTTCTGGACACTAAGGGCAGACTCTATCGTTGGCGGTCGCCCGTTATCATAGAAAAAGGGGGTAAGGTTGAGGTCGAAGGTCACCTGATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGTGGCAACCCCTTTAACCAGAGTTTCAGCGGAACAATGGGGTCGTCTCTAGACGACTTTTGCCATGATAGCACGGCTCCACAAAAGGTGCTTTTGGCGTTTTCCATTACCTACACGCCAGTAATGATATATGCTCTAAAGGTAAGTCGCGGCCGACTACTAGGGCTTCTGCACCTTTTGATCTTTCTGAATTGTGCTTTTACCTTCGGGTACATGACATTCGAGCACTTTCAGAGCACAAATAGGGTCGCGCTCACTATGGGAGCAGTAGTTGCACTTCTTTGGGGGGTGTACTCAGCCATAGAAACCTGGAAATTCATCACCTCCAGATGCCGTTTGTGCTTGCTAGGCCGCAAGTACATTCTGGCCCCTGCCCACCACGTCGAAAGTGCCGCGGGCTTTCATCCGATTGCGGCAAATGATAACCACGCATTTGTCGTCCGGCGTCCCGGCTCCACTACGGTTAACGGCACATTGGTGCCCGGGTTGAAAAGCCTCGTGTTGGGTGGCAGAAAAGCTGTTAAACAGGGAGTGGTAAACCTTGTCAAATATGCCAAATAACAACGGCAAGCAGCAAAAGAAAAAGAAGGGGAATGGCCAGCCAGTCAATCAGCTGTGCCAGATGCTGGGTAAAATCATCGCCCAGCAAAACCAGTCCAGAGGCAAGGGACCGGGCAAGAAAAGTAAGAAGAAAAACCCGGAGAAGCCCCATTTTCCTCTAGCGACCGAAGATGACGTCAGGCATCACTTCACCCCTGGTGAGCGGCAATTGTGTCTGTCGTCGATCCAGACTGCCTTTAACCAGGGCGCTGGAACTTGTACCCTGTCAGATTCAGGGAGGATAAGTTACACTGTGGAGTTTAGTTTGCCGACGCATCATACTGTGCGCCTGATCCGCGTCACAGCATCACCCTCAGCATGA",
  IngelvacATP = "ATGAAATGGGGTCCATGCAAAGCCTCTTTGACAAAATTGGCCAACTTTTCGTGGATGCTTTCACGGAATTTTTGGTGTCCATTGTTGATATCATCATATTTTTGGCCATTTTGTTTGGCTTTACCATCGCTGGCTGGCTGGTGGTCTTCTGCATCCGATTGGTTTGCTCCGCGGTACTCCGTGCGCGCCCTACCATTCACCCTGAGCAATTACAGAAGATCCTATGAGGCCTTTCTTTCTCAGTGCCAGGTGGATATTCCCACCTGGGGAACTAGACATCCCCTGGGGATGCTTTGGCACCATAAGGTGTCAACCCTGATTGATGAAATGGTGTCGCGTCGGATGTACCGCACCATGGAAAAAGCAGGACAGGCTGCCTGGAAACAGGTGGTGAGCGAGGCCACGCTGTCTCGCATTAGTGGTTTGGATGTGGTGGCTCATTTTCAGCATCTTGCCGCCATTGAAGCCGAGACCTGTAAATATTTGGCCTCTCGGCTGCCCATGCTACACAATCTGCGCATGACAGGGTCAAATGTAACCATAGTGTATAATAGTACTTTGAATCAGGTGTTTGCTATTTTTCCAACCCCTGGATCCCGGCCAAAGCTTCATGATTTTCAGCAATGGCTAATAGCTGTGCACTCCTCCATATTTTCCTCCGTTGCGGCTTCTTGTACTCTTTTTGTTGTGCTGTGGTTGCGGATTCCAATGCTACGTACTGTTTTTGGTTTCCGCTGGTTAGGGGCAATTTTTCCTTCGAACTCACGGTGAATTACACGGTGTGTCCGCCTTGCCTCACCCGGCAAGCAGCCGCTGAGGTCTACGAACCAGGCAGGTCTCTTTGGTGCAGGATAGGGCATGACCGATGTAGTGAGGAAGACCATGACGATCTAGGGTTCATGGTTCCGTCTGGCCTCTCCAGCGAAGGCCACTTGACCAGTGTTTACGCCTGGTTGGCGTTCCTGTCCTTCAGCTACACGGCCCAGTTCCATCCCGAGATATTTGGGATAGGGAATGTGAGTCAAGTTTATGTTGACATCAAGCACCAATTCATCTGCGCCGTTCACGACGGGGAGAACGCCACCTTGCCTCGTCATGACAATATTTCAGCCGTATATCAGACCTACTACCAACATCAAGTCGACGGCGGCAATTGGTTTCACCTAGAATGGCTGCGCCCCTTCTTTTCCTCTTGGTTGGTTTTAAATGTTTCTTGGTTTCTCAGGCGTTCGCCTGCAAGCCATGTTTCAGTTCAAGTCTTTCGGACATCAAAACCAACACAACCGCAGCATCAGGCTTTGTTGTCCTCCAGGACATCAGCTGCCTTAGGCATGGCGACTCGTCCTCTCAGACGATTCGCAAAAGCTCTCAGTGCCGCGCGGCGATAGGGACGCCCGTGTACATCACTGTCACAGCCAATGTCACAGATGAGAATTATTTACATTCTTCTGATCTCCTTATGCTTTCTTCTTGCCTTTTCTATGCTTCTGAGATGAGTGAAAAGGGATTCAAGGTGATGTTTGGCAATGTGTCAGGCATCGTGGCTGTGTGTGTCAACTTTACCAGCTACGTCCAACATGTCAAGGAGTTTACCCAACGCTCCTTGGTGGTCGATCATGTGCGGCTGCTCCATTTCATGACACCTGAGACCATGAGGTGGGCAACCGTTTTAGCCTGTTTTCTTGCCATCTTACTGGCAATTTGAATGTTCAAGTATGTTGGGGAGATGCTTGACCGCGGGCTGTTGCTCGCGATTGCTTTCTTTGTGGTGTATCGTGCCATTTTGTTTTGCTGCGCTCGTCAACGCCAACAGCAACAGCAGCTCTCATCTTCAGTTAATTTACAACTTGACGCTATGTGAGCTGAATGGCACAGATTGGCTGAAAGACAAATTTGATTGGGCATTGGAGACTTTTGTCATCTTTCCCGTGTTGACTCACATTGTCTCATATAGTGCACTCACCACTAGCCATTTCCTTGACACAGTCGGTCTGGTTACTGTGTCTACTGCCGGGTTCTACCACGGGCGGTATGTTCTGAGTAGCATCTACGCGGTCTGCGCTCTGGCCGCATTGACTTGCTTCGTCATTAGGCTTGCGAAGAACTGCATGTCCTGGCGCTACTCTTGTACCAGATATACTAACTTCCTTCTGGACACTAAGGGCAGACTCTATCGCTGGCGGTCGCCCGTTATCATAGAGAAAGGGGGTAAGGTTGAGGTCGAAGGTCACCTGATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGTGGCAACCCCTTTAACCAGAGTTTCAGCGGAACAATGGGGTCGTCTTTAGACGACTTTTGCTATGATAGCACGGCTCCACAAAAGGTGCTTTTGGCGTTTTCCATTACCTACACGCCAGTGATGATATATGCTCTAAAGGTAAGTCGCGGCCGACTTTTAGGGCTTCTGCACCTTTTGATCTTTCTGAATTGTACTTTTACCTTCGGGTACATGACATGCGTGCACTTTAATAGCACAAATAAGGTCGCGCTCACTATGGGAGCAGTAGTTGCACTTCTTTGGGGGGTGTACTCAGCCATAGAAACCTGGAAGTTCATCACCTCCAGATGTCGTTTGTGCTTGCTAGGCCGCAAGTACATTCTGGCCCCCGCCCACCACGTCGAAAGTGCCGCGGGCTTTCATCCGATCGCGGCAAATGATAACCACGCATTTGTCGTCCGGCGTCCCGGCTCCACTACGGTTAACGGCACATTGGTGCCCGGGTTGAAAAGCCTCGTGTTGGGTGGCAGAAAAGCTGTTAAACAGGGAGTGGTAAACCTTGTCAAATATGCCAAATAACAACGGCAAGCAGCAAAAGAAAAAGAGGGGGAATGGCCAGCCAGTCAATCAGCTGTGCCAGATGCTGGGTAAGATCATCGCCCAGCAAAACCAGTCCAGAGGCAAGGGACCGGGGAAGAAAATTAAGAATAAAAACCCGGAGAAGCCCCATTTTCCTCTAGCGACTGAAGATGACGTCAGGCATCACTTCACCCCTAGTGAGCGGCAATTGTGTCTGTCGTCGATCCAGACTGCCTTTAACCAGGGCGCTGGAACCTGTACCCTATCAGATTCAGGTAGGATAAGTTACACTGTGGAGTTTAGTTTGCCGACGCATCATACTGTGCGCCTGATCCGCGTCACAGCGCCATCATCAGCGTAA",
  VR2332 = "ATGAAATGGGGTCCATGCAAAGCCTTTTTGACAAAATTGGCCAACTTTTTGTGGATGCTTTCACGGAGTTCTTGGTGTCCATTGTTGATATCATTATATTTTTGGCCATTTTGTTTGGCTTCACCATCGCCGGTTGGCTGGTGGTCTTTTGCATCAGATTGGTTTGCTCCGCGATACTCCGTACGCGCCCTGCCATTCACTCTGAGCAATTACAGAAGATCTTATGAGGCCTTTCTTTCCCAGTGCCAAGTGGACATTCCCACCTGGGGAACTAAACATCCTTTGGGGATGCTTTGGCACCATAAGGTGTCAACCCTGATTGATGAAATGGTGTCGCGTCGAATGTACCGCATCATGGAAAAAGCAGGGCAGGCTGCCTGGAAACAGGTGGTGAGCGAGGCTACGCTGTCTCGCATTAGTAGTTTGGATGTGGTGGCTCATTTTCAGCATCTAGCCGCCATTGAAGCCGAGACCTGTAAATATTTGGCCTCCCGGCTGCCCATGCTACACAACCTGCGCATGACAGGGTCAAATGTAACCATAGTGTATAATAGCACTTTGAATCAGGTGTTTGCTATTTTTCCAACCCCTGGTTCCCGGCCAAAGCTTCATGATTTTCAGCAATGGTTAATAGCTGTACATTCCTCCATATTTTCCTCTGTTGCAGCTTCTTGTACTCTTTTTGTTGTGCTGTGGTTGCGGGTTCCAATACTACGTACTGTTTTTGGTTTCCGCTGGTTAGGGGCAATTTTTCTTTCGAACTCACAGTGAATTACACGGTGTGTCCACCTTGCCTCACCCGGCAAGCAGCCACAGAGATCTACGAACCCGGTAGGTCTCTTTGGTGCAGGATAGGGTATGACCGATGTGGGGAGGACGATCATGACGAGCTAGGGTTTATGATACCGCCTGGCCTCTCCAGCGAAGGCCACTTGACTAGTGTTTACGCCTGGTTGGCGTTCTTGTCCTTCAGCTACACGGCCCAGTTCCATCCCGAGATATTCGGGATAGGGAATGTGAGTCGAGTTTATGTTGACATCAAACATCAACTCATCTGCGCCGAACATGACGGGCAGAACACCACCTTGCCTCGTCATGACAACATTTCAGCCGTGTTTCAGACCTATTACCAACATCAAGTCGACGGCGGCAATTGGTTTCACCTAGAATGGCTTCGTCCCTTCTTTTCCTCGTGGTTGGTTTTAAATGTCTCTTGGTTTCTCAGGCGTTCGCCTGCAAACCATGTTTCAGTTCGAGTCTTGCAGATATTAAGACCAACACCACCGCAGCGGCAAGCTTTGCTGTCCTCCAAGACATCAGTTGCCTTAGGCATCGCGACTCGGCCTCTGAGGCGATTCGCAAAATCCCTCAGTGCCGTACGGCGATAGGGACACCCGTGTATGTTACCATCACAGCCAATGTGACAGATGAGAATTATTTACATTCTTCTGATCTCCTCATGCTTTCTTCTTGCCTTTTCTATGCTTCTGAGATGAGTGAAAAGGGATTTAAGGTGGTATTTGGCAATGTGTCAGGCATCGTGGCTGTGTGTGTCAATTTTACCAGCTACGTCCAACATGTCAAGGAGTTTACCCAACGCTCCCTGGTGGTCGACCATGTGCGGTTGCTCCATTTCATGACACCTGAGACCATGAGGTGGGCAACTGTTTTAGCCTGTCTTTTTGCCATTCTGTTGGCAATTTGAATGTTTAAGCATGTTGGAGAAATGCTTGACCGCGGGCTGTTGCTCGCGATTGCTTTCTTTGTGGTGTATCGTGCCGTTCTGTTTTGCTGTGCTCGCCAACGCCAGCAACGACAGCAGCTCCCATCTACAGCTGATTTACAACTTGACGCTATGTGAGCTGAATGGCACAGATTGGCTAGCTAACAAATTTGATTGGGCAGTGGAGAGTTTTGTCATCTTTCCCGTTTTGACTCACATTGTCTCCTATGGTGCCCTCACTACCAGCCATTTCCTTGACACAGTCGCTTTAGTCACTGTGTCTACCGCCGGGTTTGTTCACGGGCGGTATGTCCTAAGTAGCATCTACGCGGTCTGTGCCCTGGCTGCGTTGACTTGCTTCGTCATTAGGTTTGCAAAGAATTGCATGTCCTGGCGCTACGCGTGTACCAGATATACCAACTTTCTTCTGGACACTAAGGGCAGACTCTATCGTTGGCGGTCGCCTGTCATCATAGAGAAAAGGGGCAAAGTTGAGGTCGAAGGTCATCTGATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGTGGCAACCCCTATAACCAGAGTTTCAGCGGAACAATGGGGTCGTCCTTAGATGACTTCTGTCATGATAGCACGGCTCCACAAAAGGTGCTTTTGGCGTTTTCTATTACCTACACGCCAGTGATGATATATGCCCTAAAGGTGAGTCGCGGCCGACTGCTAGGGCTTCTGCACCTTTTGATCTTCCTGAATTGTGCTTTCACCTTCGGGTACATGACTTTCGCGCACTTTCAGAGTACAAATAAGGTCGCGCTCACTATGGGAGCAGTAGTTGCACTCCTTTGGGGGGTGTACTCAGCCATAGAAACCTGGAAATTCATCACCTCCAGATGCCGTTTGTGCTTGCTAGGCCGCAAGTACATTCTGGCCCCTGCCCACCACGTTGAAAGTGCCGCAGGCTTTCATCCGATTGCGGCAAATGATAACCACGCATTTGTCGTCCGGCGTCCCGGCTCCACTACGGTCAACGGCACATTGGTGCCCGGGTTAAAAAGCCTCGTGTTGGGTGGCAGAAAAGCTGTTAAACAGGGAGTGGTAAACCTTGTCAAATATGCCAAATAACAACGGCAAGCAGCAGAAGAGAAAGAAGGGGGATGGCCAGCCAGTCAATCAGCTGTGCCAGATGCTGGGTAAGATCATCGCTCAGCAAAACCAGTCCAGAGGCAAGGGACCGGGAAAGAAAAATAAGAAGAAAAACCCGGAGAAGCCCCATTTTCCTCTAGCGACTGAAGATGATGTCAGACATCACTTTACCCCTAGTGAGCGGCAATTGTGTCTGTCGTCAATCCAGACCGCCTTTAATCAAGGCGCTGGGACTTGCACCCTGTCAGATTCAGGGAGGATAAGTTACACTGTGGAGTTTAGTTTGCCTACGCATCATACTGTGCGCCTGATCCGCGTCACAGCATCACCCTCAGCATGA",
  IngelvacMLV = "ATGAAATGGGGTCCATGCAAAGCCTTTTTTACAAAATTGGCCAACTTTTTGTGGATGCTTTCACGGAGTTCTTGGTGTCCATTGTTGATATCATTATATTTTTGGCCATTTTGTTTGGCTTCACCATCGCCGGTTGGCTGGTGGTCTTTTGCATCAGATTGGTTTGCTCCGCGATACTCCGTACGCGCCCTGCCATTCACTCTGAGCAATTACAGAAGATCTTATGAGGCCTTTCTTTCCCAGTGCCAAGTGGACATTCCCACCTGGGGAACTAAACATCCTTTGGGGATGCTTTGGCACCATAAGGTGTCAACCCTGATTGATGAAATGGTGTCGCGTCGAATGTACCGCATCATGGAAAAAGCAGGGCAGGCTGCCTGGAAACAGGTGGTGAGCGAGGCTACGCTGTCTCGCATTAGTAGTTTGGATGTGGTGGCTCATTTTCAGCATCTAGCCGCCATTGAAGCCGAGACCTGTAAATATTTGGCCTCCCGGCTGCCCATGCTACACAACCTGCGCATGACAGGTTCAAATGTAACCATAGTGTATAATAGCACTTTGAATCAGGTGTTTGCTATTTTTCCAACCCCTGGTTCCCGGCCAAAGCTTCATGATTTTCAGCAATGGTTAATAGCTGTACATTCCTCCATATTTTCCTCTGTTGCAGCTTCTTGTACTCTTTTTGTTGTGCTGTGGTTGCGGGTTCCAATACTACGTACTGTTTTTGGTTTCCGCTGGTTAGGGGCAATTTTTCTTTCGAACTCACAGTGAATTACACGGTGTGTCCACCTTGCCTCACCCGGCAAGCAGCCACAGAGATCTACGAACCCGGTAGGTCTCTTTGGTGCAGGATAGGGTATGACCGATGTGAGGAGGATGATCATGACGAGCTAGGGTTTATGATACCGCCTGGCCTCTCCAGCGAAGGCCACTTGACTAGTGTTTACGCCTGGTTGGCGTTCTTGTCCTTCAGCTACACGGCCCAGTTCCATCCCGAGATATTCGGGATAGGGAATGTGAGTCGAGTTTATGTTGACATCAAACATCAACTCATCTGCGCCGAACATGACGGGCAGAACACCACCTTGCCTCGTCATGACAACATTTCAGCCGTGTTTCAGACCTATTACCAACATCAAGTCGACGGCGGCAATTGGTTTCACCTAGAATGGCTTCGTCCCTTCTTTTCCTCGTGGTTGGTTTTAAATGTCTCTTGGTTTCTCAGGCGTTCGCCTGCAAACCATGTTTCAGTTCGAGTCTTGCAGATATTAAGACCAACACCACCGCAGCGGCAAGCTTTGCTGTCCTCCAAGACATCAGTTGCCTTAGGCATCGCGACTCGGCCTCTGAGGCGATTCGCAAAATCCCTCAGTGCCGTACGGCGATAGGGACACCCGTGTATGTTACCATCACAGCCAATGTGACAGATGAGAATTATTTACATTCTTCTGATCTCCTCATGCTTTCTTCTTGCCTTTTCTATGCTTCTGAGATGAGTGAAAAGGGATTTAAGGTGGTATTTGGCAATGTGTCAGGCATCGTGGCTGTGTGTGTCAATTTTACCAGCTACGTCCAACATGTCAAGGAGTTTACCCAACGCTCCCTGGTGGTCGACCATGTGCGGTTGCTCCATTTCATGACACCTGAGACCATGAGGTGGGCAACTGTTTTAGCCTGTCTTTTTGCCATTCTGTTGGCAATTTGAATGTTTAAGTATGTTGGAGAAATGCTTGACCGCGGGCTGTTGCTCGCAATTGCTTTCTTTGTGGTGTATCGTGCCGTTCTGTTTTGCTGTGCTCGCCAACGCCAGCAACGACAGCAGCTCCCATCTACAGCTGATTTACAACTTGACGCTATGTGAGCTGAATGGCACAGATTGGCTAGCTAACAAATTTGATTGGGCAGTGGAGAGTTTTGTCATCTTTCCCGTTTTGACTCACATTGTCTCCTATGGTGCCCTCACTACCAGCCATTTCCTTGACACAGTCGCTTTAGTCACTGTGTCTACCGCCGGGTTTGTTCACGGGCGGTATGTCCTAAGTAGCATCTACGCGGTCTGTGCCCTGGCTGCGTTGACTTGCTTCGTCATTAGGTTTGCAAAGAATTGCATGTCCTGGCGCTACGCGTGTACCAGATATACCAACTTTCTTCTGGACACTAAGGGCGGACTCTATCGTTGGCGGTCGCCTGTCATCATAGAGAAAAGGGGCAAAGTTGAGGTCGAAGGTCATCTGATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGTGGCAACCCCTATAACCAGAGTTTCAGCGGAACAATGGGGTCGTCCTTAGATGACTTCTGTCATGATAGCACGGCTCCAGAAAAGGTGCTTTTGGCGTTTTCTATTACCTACACGCCAGTGATGATATATGCCCTAAAGGTGAGTCGCGGCCGACTGCTAGGGCTTCTGCACCTTTTGATCTTCCTGAATTGTGCTTTCACCTTCGGGTACATGACTTTCGCGCACTTTCAGAGTACAAATAAGGTCGCGCTCACTATGGGAGCAGTAGTTGCACTCCTTTGGGGGGTGTACTCAGCCATAGAAACCTGGAAATTCATCACCTCCAGATGCCGTTTGTGCTTGCTAGGCCGCAAGTACATTCTGGCCCCTGCCCACCACGTTGAAAGTGCCGCAGGCTTTCATCCGATTGCGGCAAATGATAACCACGCATTTGTCGTCCGGCGTCCCGGCTCCACTACGGTCAACGGCACATTGGTGCCCGGGTTAAAAAGCCTCGTGTTGGGTGGCAGAAAAGCTGTTAAACAGGGAGTGGTAAACCTTGTCAAATATGCCAAATAACAACGGCAAGCAGCAGAAGAGAAAGAAGGGGGATGGCCAGCCAGTCAATCAGCTGTGCCAGATGCTGGGTAAGATCATCGCTCAGCAAAACCAGTCCAGAGGCAAGGGACCGGGAAAGAAAAATAAGAAGAAAAACCCGGAGAAGCCCCATTTTCCTCTAGCGACTGAAGATGATGTCAGACATCACTTTACCCCTAGTGAGCGGCAATTGTGTCTGTCGTCAATCCAGACCGCCTTTAATCAAGGCGCTGGGACTTGCACCCTGTCAGATTCAGGGAGGATAAGTTACACTGTGGAGTTTAGTTTGCCTACGCATCATACTGTGCGCCTGATCCGCGTCACAGCATCACCCTCAGCATGA",
  PrimePac = "ATGAAATGGGGTCCATGCAAAGCCTTTTTGACAAAATTGGTCAACTTTTTGTGGATGCTTTCACGGAATTCTTGGTGTCCATTGTTGATATCATCATATTTTTGGCCATTTTGTTTGGCTTCACCGTCGCCGGTTGGCTGGTGGTCTTTTGCATCAGATTGGTTTGCTCCGCGATACTCCGTGCACGCCCTGCCTTTCACTCTGAGCAGTTACAGAAGATCCTATGAGGCCTTTCTTTCCCAGTGTCAGGTGGACATTCCCACCTGGGGAATCAAACATCCTCTGGGGGTGCTTTGGCACCATAAGGTGTCAACCCTGATTGATGAAATGGTGTCGCGTCGAATGTACCGCATCATGGAAAAAGCAGGACAGGCTGCCTGGAAACAGGTGGTGAGCGAGGCCACGCTGTCTCGCATTAGTAGTTTGGATGTGGTGGCTCATTTTCAACATCTTGCCGCCGTTGAAGCCGAGACCTGTAAATATTTGGTCTCTCGGCTACCCATGCTACACAACCTGCGCATGACGGGGTCAAATGTAACCATAGTATATAATGGTACTTTGAATCAGGTGTTTGCCATTTTCCCGACCCCTGGTTCCCGGCCAAAGCTTCATGATTTTCAGCAATGGCTGATAGCTGTGCATTCGTCCATATTTTCCTCTGTTGCAGCTTCTTGTACTCTGTTTGTTGTACTGTGGTTGCGGGTCCCAATGCTACGTACTGTTTTTGGTTTCCGCTGGTTAGGGGCAATTTTTCCTTCGAGCTCTTGGTGAATTACACGGTGTGCCCACCTTGCCTCACCCGGCAAGCAGCCGCACAGCGCTACGAACCTGGCAAGGCTCTTTGGTGCAGAATTGGGTACGATCGATGTGAGGAGGACGATCACGACGAGCTAGGGTTCGTGATACCGTCTGGCCTCTCCAGCGAAGGCCACTTGACTAGTGTTTACGCCTGGTTGGCGTTTTTGTCCTTCAGTTACACGGCCCAGTTTCATCCTGAGATATTCGGGATAGGGAATGTGAGCAAAGTCTATGTTGACATCAAACACCAATTCATCTGCGCTGTTCATGATGGGCAGAACACCACCTTGCCCCGCCATGACAACTTTTCAGCCGTGTTTCAGACCTATTACCAGCATCAAGTCGACGGCGGCAATTGGTTTCACCTAGAATGGCTGCGTCCCTTCTTTTCCTCTTGGTTGGTTTTAAATGTCTCGTGGTTTCTCAGGCGTTTGCCTGCAAGCCATGTTTCAGTTCGAGTCTTTCAGACATTAAGACCAACACCACCGCAGCAGCGGGCTTTGCTGTCCTCCAGGACATCAGCTGCCTTAGGCATGGCGACCCGTCCTCTGCGGCGATTCGCAAAAGCTCTCAGTGCCGCACGGCGATAGGGACACCCGTGTATATCACCATTACAGCCAATGTGACAGATGAGAATTATTTACACTCCTCTGATCTCCTCATGCTTTCTTCTTGCCTTTTCTATGCTTCTGAGATGAGTGAAAAGGGATTTAAGGTGGTATTTGGCAATGTGTCAGGCATCGTGGCTGTGTGTGTTAATTTTACCAGCTACGTCCAACATGTCAGGGACTTCACCCAACGCTCCTTGGTGGTCGATCATGTGCGGCTGCTCCATTTCATGACACCTGAGGCCATGAGGTGGGCAACTGTTTTACCCTGTCTTTTTGCCATTCTGTTGGCAGTTTGAATGTTTAAGTATGTTGGGGAAATGCTTGACCGCGGGTTGCTGCTCGCGATTGCTTTCTTTTTGGTGTATCGTGCCGTTCTGTTTTGCTGTGCTCGTCAACGCCAGCTACAGCAGCAGCTCTCATTTACAGTTGATTTATAACTTGACGCTATGTGAGCTGAATGGTACAGATTGGCTGGCTAATAAATTTGATTGGGCAGTGGAGAGTTTTGTCATCTTTCCTGTGTTGACCCACATCGTTTCCTATGGTGCACTAACCACCAGCCACTTCCTTGACACAGTTGGTCTGGTTACTGTGTCTACCGCCGGGTTTTATCATGGGCGGTATGTCCTGAGTAGCATCTACGCGGTCTGTGCCCTGGCTGCGTTAATTTGCTTCGTCATTAGGTTGGCGAAGAACTGTATGTCCTGGCGCTACTCATGCACCAGATACACCAACTTTCTTCTGGACACTAAGGGCAGACTCTATCGTTGGCGGTCGCCTGTCATCATAGAGAAAGGGGGTAAGGTAGAGGTCGAAAGCCATCTGATCGACCTCAAAAGAGTTGTGCTTGATGGGTCCGCGGCAACCCCTTTAACCAGAGTTTCAGCGGAACAATGGGGTCGTCCCTAGACGACTTTTGTCATGACAGCACGGCTCCACAGAAGGTGCTCTTGGCGTTTTCTATTACTTACACGCCAGTGATGATATATGCCCTAAAGGTAAGTCGCGGCCGATTGCTGGGGCTTCTGCACCTTCTGATCTTCCTGAATTGTGCTTTCACCTTCGGGTATATGACATTCGCGCACTTTCAGAGTACAAATAGGGTCGCGCTCACTATGGGAGCAGTAGTTGCACTCCTTTGGGGGGTGTACTCAGCCATAGAAACTTGGAGGTTCATCACCTCTAGATGCCGTTTGTGCTTGTTAGGCCGCAGGTACATTCTGGCCCCTGCCCACCACGTTGAAAGTGCCGCAGGCTTTCATCCGATTACGGCAAATGATAACCACGCATTTGTCGTCCGGCGTCCCGGCTCCACTACGGTTAACGGCACATTGGTGCCCGGGTTGAAGAGCCTCGTGTTGGGTGGCAGAAAAGCTGTAAAACGGGGAGTGGTTAACCTTGTTAAATATGCCAAATAACAACGGCAAACAGCAGAAGAAAAAGAAGGGGGATGGCCAGCCAGTCAATCAGCTGTGCCAGATGCTGGGTAAGATCATCGCCCAGCAAAACCAGTCCAGAGGTAAGGGACCGGGAAAGAAAAACAAGAAGAAAAACCCGGAGAAGCCCCATTTTCCTCTGGCGACTGAATATGACGTCAGACACCACTTTACCCCTAGTGAGCGGCAATTGTGCCTGTCGTCAATACAGACTGCCTTTAATCAAGGCGCTGGTACTTGCACCCTGTCCGATTCAGGGAGGATAAGTTACACTGTGGAGTTTAGTTTGCCCACGCATCATACTGTGCGCCTGATTCGCGTCACAGCATCACCCTCAGCATGA",
  Prevacent = "ATGAAATGGGGGCTGTGCAGAGCCTTTTCGACAAAATTTGCCAACTTTTTGTGGATGCTTTCACGGAATTTTTGGTGTCCATTGTTGATATCATCATATTTTTGGCCATTTTGTTTGGCTTCACCATCGCAGGCTGGCTGGTTGTCTTCTGTATCCGACTGGTTTGCTCCACGGTACTCCGTGCGCGCTCTACCATTCACCCTGAGCAATTACAGAAGATCCTATGAGGCCTTCCTTTCCCAGTGCCAAGTGGACATTCCCGCCTGGGGAACTAAGCATCCCTTGGGGGTGCTTTGGCACCACAAGGTGTCAACTCTGATTGATGAAATGGTGTCGCGTCGAATGTACCGCATCATGGAAAAAGCAGGACAGGCTGCCTGGAAACAGGTTGTGAGCGAAGCTACATTGTCTCGCATAAGTGGCTTGGATGTGGTGGCTCATTTTCAGCATCTTGCTGCCATTGAAGCCGAGACTTGCAAATATTTGGCCTCTCGGCTGCCCATGCTACACAACCTAGTCATGTCAGGGTCGAATGTAACCATAGTGTATAATAGCACTTTGGGTCAAGTGTTTGCCATTTTCCCAACCCCTGGTTCCCGGCCAAAACTTTCTGATTTTCAACAATGGCTCATAGCTGTGCATTCTTCCATATTTTCTTCTGTTGCGGCTTCTTGTACTCTTTTTGTTGTGCTGTGGCTGCGAATTCCAATACTACGTACTGTTTTTGGTTTCCGCTGGTTAGGGGCAACTTTTCTTTCGAACTCACAGTGAATTACACGGTGTGCCCACCCTGCCTCACCCGGCAAGCAGCCGCTGAGATCTACGAACACAGCGGGTCTCTTTGGTGCAGGATAGGGCATGACCGATGTAGCCAGAGTGATCATGACGAACTAGGGTTCTTGGTTCCACCTGGCCTTTCCAGCGAGGGCCACTTGACCAGTGTTTACGCCTGGCTGGCGTTCTTGTCTTTCAGCTACACAGCCCAGTTCCACCCCGAGATATTTGGAATAGGGAATGTGAGTAGAGTTTATGTTGACGTCACTCACCAACTCATCTGCGCCGAACACGACGGGCAGAACACCACCCTGCGTCGCCATGACAATATCTCAGCCGTGTTTCAGACCTATTACCAACATCAGGTCGATGGCGGCAATTGGTTTCACCTAGAATGGCTGCGTCCCTTCTTTTCCTCTTGGCTGGTTTTGAATGTCTCGTGGTTTCTCAGGCGTTCGCCTGCAAACCGTGTTTCAGTTCGAGTCTTTCAGACATCAAAACCAACACCACCGCAGCTGCAGGCTTTGCTGTCCTCCAAGACATCAGCTGTCTTAGGCATGGCTACTCGTCCATTGAGGCGATTCGCAAAAGCCGTCAATGCCGCACGGCGATAGGAACGCCCGTGTACATCACTGTCACGGCCAATGTAACAGATGAGAATTACTTGCATTCCTCTGATCTCCTCATGCTTTCCTCTTGCCTCTTCTATGCTTCTGAGATGAGTGAAAAGGGATTCAATGTGGTCTTCGGCAACGTGTCAGGCATTGTGGCTGTGTGTGTCAACTTTACCAGCTATGTCCAACATGTTAAGGAGTTTACTCAGCGCTCTTTGGTGGTCGACCACGTGCGACTGCTTCATTTCATGACACCTGCGACCATGAGGTGGGCAACAGTTTTAGCCTGTCTTTTCGCCATCTTGTTGGCGATTTGAATGTTTAAGTATGTTGGGGAAATGCTTGACCGCGGGCTACTGCTCGCAATTGCTTTTTTTCTGGTGTATCGTGCCGTTCTGTTTTGCTGCGCTCGTCAACGCCGCCAGCAACAGCAGCTCCCATTTACAGTTGATTTATAACCTGACGATATGCGAGCTGAATGGCACAGATTGGTTGAATCAAAAGTTTGATTGGGCAGTGGAGACTTTTGTCATTTTTCCTGTGTTGACCCACATTGTCTCCTACGGTGCCCTTACCACCAGCCATTTCCTTGACACGGCCGGCCTAATCACTGTGTCTACCGCCGGATATTACCATGGGCGGTATGTGTTGAGTAGCATCTACGCCGTCTTTGCCCTGGCTGCGTTGATTTGTTTTGTCATTAGGTTGACAAAAAACTGTATGTCCTGGCGCTACTCATGTACCAGATATACCAACTTTCTTCTGGACACCAAAGGCAATCTCTATCGTTGGCGGTCACCCGTCGTTATAGAGAGAAGGGGTAAAGTTGAGGTTGGAGACCACCTAATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGCGGCAACCCCTATAACCAAGATTTCAGCGGAACAATGGGGTCGTCCCTAGACGACTTCTGCAATGACAGCACAGCTGCACAAAAGGTGCTTTTGGCGTTTTCCATCACCTATACGCCAATAATGATATATGCCCTGAAGGTAAGTCGCGGCCGACTGTTAGGGCTTTTGCATCTTTTAATTTTCTTGAATTGTGCTTTCACCTTCGGGTACATGACATTTGTTCATTTTCAGAGTACAAACAAGGTCGCGCTCACTATGGGAGCAGTTGTTGCACTCCTTTGGGGGGTGTACTCAGCCATAGAAACCTGGAAATTCATCACTTCCAGATGCCGTTTGTGCTTGCTAGGCCGCAGGTACATTCTGGCCCCTGCCCACCACGTTGAAAGTGCCGCGGGCTTTCATCCGATTGCGGCAAGTGATAACCACGCATTTGTCGTCCGGCGTCCCGGCTCCACTACTGTTAACGGCACATTGGTGCCCGGGTTGAAAAGCCTCGTGTTGGGTGGCAGAAAAGCTGTTAAGCGGGGAGTGGTAAACCTCGTTAAATATGCCAAATAACAACGGCAGGCAGCAAAAAAATAAGAAGGGGAGTGGCCAGCCAGTCAATCAGCTGTGCCAAATGCTGGGCAAGATCATCGCCCAGCAAAATCAGTCCAGAGGCAAGGGACCGGGTAAGAAAAATAAGAAGAGAAACCCGGAGAAGCCCCATTTTCCTCTTGCGACCGAAGATGACGTCAGGCATCACTTCACCCCCAGTGAACGGCAATTGTGTCTGTCGTCGATCCAGACTGCCTTCAACCAGGGCGCTGGAACTTGCACCCTGTCAGATTCAGGGAGGATAAGTTACACTGTGGAGTTTAGTTTGCCGACGCACCACACTGTGCGCCTTATTCGCGCCACAGCATCACCTCCATCGTGA"
)
# ==================================================================

# Predefined variants for vaccine strains
vaccine_variants <- list(
  Fostera = "8C.1",
  IngelvacATP = "8A.1", 
  VR2332 = "5A.1",
  IngelvacMLV = "5A.1",
  PrimePac = "7.1",
  Prevacent = "1D.2"
)

# SINGLE-GENE: ORF5 AA sequences
serum_strains <- list(
  Fostera = "MLGKCLTAGCCSRLLSLWCIVPFCFAVLGSANSSSSSHFQLIYNLTLCELNGTDWLAEKFDWAVETFVIFPVLTHIVSYGALTTSHFLDTVGLVTVSTAGFYHGRYVLSSIYAVCALAALICFVIRLAKNCMSWRYSCTRYTNFLLDTKGRLYRWRSPVIIEKGGKVEVEGHLIDLKRVVLDGSVATPLTRVSAEQWGRLX",
  IngelvacATP = "MLGRCLTAGCCSRLLSLWCIVPFCFAALVNANSNSSSHLQLIYNLTLCELNGTDWLKDKFDWALETFVIFPVLTHIVSYSALTTSHFLDTVGLVTVSTAGFYHGRYVLSSIYAVCALAALTCFVIRLAKNCMSWRYSCTRYTNFLLDTKGRLYRWRSPVIIEKGGKVEVEGHLIDLKRVVLDGSVATPLTRVSAEQWGRLX",
  VR2332 = "MLEKCLTAGCCSRLLSLWCIVPFCFAVLANASNDSSSHLQLIYNLTLCELNGTDWLANKFDWAVESFVIFPVLTHIVSYGALTTSHFLDTVALVTVSTAGFVHGRYVLSSIYAVCALAALTCFVIRFAKNCMSWRYACTRYTNFLLDTKGRLYRWRSPVIIEKRGKVEVEGHLIDLKRVVLDGSVATPITRVSAEQWGRPX",
  IngelvacMLV = "MLEKCLTAGCCSQLLSLWCIVPFCFAVLANASNDSSSHLQLIYNLTLCELNGTDWLANKFDWAVESFVIFPVLTHIVSYGALTTSHFLDTVALVTVSTAGFVHGRYVLSSIYAVCALAALTCFVIRFAKNCMSWRYACTRYTNFLLDTKGGLYRWRSPVIIEKRGKVEVEGHLIDLKRVVLDGSVATPITRVSAEQWGRPX",
  PrimePac = "MLGKCLTAGCCSRLLSFWCIVPFCFAVLVNASYSSSSHLQLIYNLTLCELNGTDWLANKFDWAVESFVIFPVLTHIVSYGALTTSHFLDTVGLVTVSTAGFYHGRYVLSSIYAVCALAALICFVIRLAKNCMSWRYSCTRYTNFLLDTKGRLYRWRSPVIIEKGGKVEVESHLIDLKRVVLDGSAATPLTRVSAEQWGRPX",
  Prevacent = "MLGKCLTAGYCSQLLFFWCIVPFCFAALVNAASNSSSHLQLIYNLTICELNGTDWLNQKFDWAVETFVIFPVLTHIVSYGALTTSHFLDTAGLITVSTAGYYHGRYVLSSIYAVFALAALICFVIRLTKNCMSWRYSCTRYTNFLLDTKGNLYRWRSPVVIERRGKVEVGDHLIDLKRVVLDGSAATPITKISAEQWGRPX"
)

# SINGLE-GENE: ORF5 NT sequences
serum_nt_strains <- list(
  Fostera = "ATGTTGGGGAAATGCTTGACCGCGGGCTGTTGCTCGCGATTGCTTTCTTTGTGGTGTATCGTGCCGTTCTGTTTTGCTGTGCTCGGCAGCGCCAACAGCAGCAGCAGCTCTCATTTTCAGTTGATTTATAACTTGACGCTATGTGAGCTGAATGGCACAGATTGGCTGGCAGAAAAATTTGATTGGGCAGTGGAGACTTTTGTCATCTTTCCCGTGTTGACTCACATTGTTTCCTATGGTGCACTCACCACCAGCCATTTCCTTGACACAGTTGGTCTGGTTACTGTGTCCACCGCCGGGTTTTATCACGGGCGGTATGTCTTGAGTAGCATCTACGCGGTCTGTGCTCTGGCTGCGTTGATTTGCTTCGTTATTAGGCTTGCGAAGAACTGCATGTCCTGGCGCTACTCTTGTACCAGATATACCAACTTCCTTCTGGACACTAAGGGCAGACTCTATCGTTGGCGGTCGCCCGTTATCATAGAAAAAGGGGGTAAGGTTGAGGTCGAAGGTCACCTGATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGTGGCAACCCCTTTAACCAGAGTTTCAGCGGAACAATGGGGTCGTCTCTAG",
  IngelvacATP = "ATGTTGGGGAGATGCTTGACCGCGGGCTGTTGCTCGCGATTGCTTTCTTTGTGGTGTATCGTGCCATTTTGTTTTGCTGCGCTCGTCAACGCCAACAGCAACAGCAGCTCTCATCTTCAGTTAATTTACAACTTGACGCTATGTGAGCTGAATGGCACAGATTGGCTGAAAGACAAATTTGATTGGGCATTGGAGACTTTTGTCATCTTTCCCGTGTTGACTCACATTGTCTCATATAGTGCACTCACCACTAGCCATTTCCTTGACACAGTCGGTCTGGTTACTGTGTCTACTGCCGGGTTCTACCACGGGCGGTATGTTCTGAGTAGCATCTACGCGGTCTGCGCTCTGGCCGCATTGACTTGCTTCGTCATTAGGCTTGCGAAGAACTGCATGTCCTGGCGCTACTCTTGTACCAGATATACTAACTTCCTTCTGGACACTAAGGGCAGACTCTATCGCTGGCGGTCGCCCGTTATCATAGAGAAAGGGGGTAAGGTTGAGGTCGAAGGTCACCTGATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGTGGCAACCCCTTTAACCAGAGTTTCAGCGGAACAATGGGGTCGTCTTTAG",
  VR2332 = "ATGTTGGAGAAATGCTTGACCGCGGGCTGTTGCTCGCGATTGCTTTCTTTGTGGTGTATCGTGCCGTTCTGTTTTGCTGTGCTCGCCAACGCCAGCAACGACAGCAGCTCCCATCTACAGCTGATTTACAACTTGACGCTATGTGAGCTGAATGGCACAGATTGGCTAGCTAACAAATTTGATTGGGCAGTGGAGAGTTTTGTCATCTTTCCCGTTTTGACTCACATTGTCTCCTATGGTGCCCTCACTACCAGCCATTTCCTTGACACAGTCGCTTTAGTCACTGTGTCTACCGCCGGGTTTGTTCACGGGCGGTATGTCCTAAGTAGCATCTACGCGGTCTGTGCCCTGGCTGCGTTGACTTGCTTCGTCATTAGGTTTGCAAAGAATTGCATGTCCTGGCGCTACGCGTGTACCAGATATACCAACTTTCTTCTGGACACTAAGGGCAGACTCTATCGTTGGCGGTCGCCTGTCATCATAGAGAAAAGGGGCAAAGTTGAGGTCGAAGGTCATCTGATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGTGGCAACCCCTATAACCAGAGTTTCAGCGGAACAATGGGGTCGTCCTTAG",
  IngelvacMLV = "ATGTTGGAGAAATGCTTGACCGCGGGCTGTTGCTCGCAATTGCTTTCTTTGTGGTGTATCGTGCCGTTCTGTTTTGCTGTGCTCGCCAACGCCAGCAACGACAGCAGCTCCCATCTACAGCTGATTTACAACTTGACGCTATGTGAGCTGAATGGCACAGATTGGCTAGCTAACAAATTTGATTGGGCAGTGGAGAGTTTTGTCATCTTTCCCGTTTTGACTCACATTGTCTCCTATGGTGCCCTCACTACCAGCCATTTCCTTGACACAGTCGCTTTAGTCACTGTGTCTACCGCCGGGTTTGTTCACGGGCGGTATGTCCTAAGTAGCATCTACGCGGTCTGTGCCCTGGCTGCGTTGACTTGCTTCGTCATTAGGTTTGCAAAGAATTGCATGTCCTGGCGCTACGCGTGTACCAGATATACCAACTTTCTTCTGGACACTAAGGGCGGACTCTATCGTTGGCGGTCGCCTGTCATCATAGAGAAAAGGGGCAAAGTTGAGGTCGAAGGTCATCTGATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGTGGCAACCCCTATAACCAGAGTTTCAGCGGAACAATGGGGTCGTCCTTAG",
  PrimePac = "ATGTTGGGGAAATGCTTGACCGCGGGTTGCTGCTCGCGATTGCTTTCTTTTTGGTGTATCGTGCCGTTCTGTTTTGCTGTGCTCGTCAACGCCAGCTACAGCAGCAGCTCTCATTTACAGTTGATTTATAACTTGACGCTATGTGAGCTGAATGGTACAGATTGGCTGGCTAATAAATTTGATTGGGCAGTGGAGAGTTTTGTCATCTTTCCTGTGTTGACCCACATCGTTTCCTATGGTGCACTAACCACCAGCCACTTCCTTGACACAGTTGGTCTGGTTACTGTGTCTACCGCCGGGTTTTATCATGGGCGGTATGTCCTGAGTAGCATCTACGCGGTCTGTGCCCTGGCTGCGTTAATTTGCTTCGTCATTAGGTTGGCGAAGAACTGTATGTCCTGGCGCTACTCATGCACCAGATACACCAACTTTCTTCTGGACACTAAGGGCAGACTCTATCGTTGGCGGTCGCCTGTCATCATAGAGAAAGGGGGTAAGGTAGAGGTCGAAAGCCATCTGATCGACCTCAAAAGAGTTGTGCTTGATGGGTCCGCGGCAACCCCTTTAACCAGAGTTTCAGCGGAACAATGGGGTCGTCCCTAG", 
  Prevacent = "ATGTTGGGGAAATGCTTGACCGCGGGCTACTGCTCGCAATTGCTTTTTTTCTGGTGTATCGTGCCGTTCTGTTTTGCTGCGCTCGTCAACGCCGCCAGCAACAGCAGCTCCCATTTACAGTTGATTTATAACCTGACGATATGCGAGCTGAATGGCACAGATTGGTTGAATCAAAAGTTTGATTGGGCAGTGGAGACTTTTGTCATTTTTCCTGTGTTGACCCACATTGTCTCCTACGGTGCCCTTACCACCAGCCATTTCCTTGACACGGCCGGCCTAATCACTGTGTCTACCGCCGGATATTACCATGGGCGGTATGTGTTGAGTAGCATCTACGCCGTCTTTGCCCTGGCTGCGTTGATTTGTTTTGTCATTAGGTTGACAAAAAACTGTATGTCCTGGCGCTACTCATGTACCAGATATACCAACTTTCTTCTGGACACCAAAGGCAATCTCTATCGTTGGCGGTCACCCGTCGTTATAGAGAGAAGGGGTAAAGTTGAGGTTGGAGACCACCTAATCGACCTCAAAAGAGTTGTGCTTGATGGTTCCGCGGCAACCCCTATAACCAAGATTTCAGCGGAACAATGGGGTCGTCCCTAG"
)

# Model paths
# SINGLE-GENE
lightgbm_sg_model_path <- "lightgbm_vs_2class_model_ectodomain.txt"
lightgbm_sg_features_path <- "lightgbm_vs_2class_model_ectodomain_features.csv"

# MULTI-GENE
lightgbm_mg_model_path <- "AllGenes_noRMSD_lightgbm_vs_2class_model_ectodomain.txt"
lightgbm_mg_features_path <- "AllGenes_noRMSD_lightgbm_vs_2class_model_ectodomain_features.csv"

# Ectodomain ranges
orf5_ectodomain_ranges <- list(c(27, 64), c(100, 109))

# Multi-gene ectodomain ranges (amino acid positions)
ectodomain_ranges <- list(
  orf2 = list(c(40, 208)),
  orf3 = list(c(29, 182)),
  orf4 = list(c(22, 156)),
  orf5 = list(c(27, 64), c(100, 109)),
  orf6 = list(c(1, 16))
)

ui <- navbarPage(
  title = em("PRRSLoom-Neutralization Predictor", style = "color: gold; font-size: 150%;text-align: right"),
  id = "nav",
  theme = shinytheme("cosmo"),
  header = tagList(
    shinyjs::useShinyjs()
  ),
  tabPanel("Home", icon = icon("dashboard"),
           fluidPage(
             fluidRow(
               column(5,
                      # MODEL SELECTION
                      radioButtons("model_type", "Choose Prediction Model:",
                                   choices = c(
                                     "Single-Gene (ORF5 only)" = "single",
                                     "Multi-Gene (ORF2-ORF7)" = "multi"
                                   ),
                                   selected = "single"
                      ),
                      hr(),
                      
                      radioButtons("inputmode", "Choose Input Mode:",
                                   choices = c(
                                     "Upload outbreak virus sequence(s) only" = "viral_only",
                                     "Upload both vaccine/LVI virus sequence(s) and outbreak virus sequence(s)" = "both"
                                   ),
                                   selected = "viral_only"
                      ),
                      
                      fileInput("file_viral", em("Upload/drag and drop outbreak virus FASTA file", style = "color:maroon;font-size:120%")),
                      tags$p(style = "font-size: 85%; color: #666; margin-top: -10px;", "(Maximum file size: 5 MB)"),
                      conditionalPanel(condition = "input.inputmode == 'both'",
                                       fileInput("file_serum", em("Upload/drag and drop vaccine/LVI virus FASTA file", style = "color:navy;font-size:120%")),
                                       tags$p(style = "font-size: 85%; color: #666; margin-top: -10px;", "(Maximum file size: 5 MB)")
                      ),
                      
                      tags$h4("Or paste your outbreak virus FASTA sequence(s) below:"),
                      textAreaInput("fasta_viral", "Paste outbreak virus FASTA here", rows = 5),
                      conditionalPanel(condition = "input.inputmode == 'both'",
                                       tags$h4("Or paste your vaccine/LVI virus FASTA sequence(s) below:"),
                                       textAreaInput("fasta_serum", "Paste vaccine/LVI virus FASTA here", rows = 5)
                      ),
                      
                      actionButton("runpred", "Run Prediction", icon = icon("play"), style = "color:darkgoldenrod;font-size:150%"),
                      conditionalPanel(condition = "output.showResults",
                                       downloadButton("downloadSummary", em("Download Summary Table", style = "color:darkgoldenrod;font-size:150%"))
                      ),
                      br(), br(),
                      downloadButton("downloadLog", em("Download Log File", style = "color:darkgoldenrod;font-size:120%"))
               ),
               column(7,
                      tags$div(
                        style = "background-color: #e8f4f8; padding: 10px; border-radius: 5px; margin-bottom: 15px;",
                        tags$p(style = "margin: 0; font-size: 95%;", 
                               tags$b("Welcome!"), " This tool predicts whether PRRSV-2 outbreak viruses will be neutralized by vaccine or LVI sera. 
                               Both single-gene and multi-gene models show similar performance on internal test data (90-93% accuracy), 
                               but only the single-gene model has been validated with external test data (83% accuracy). 
                               Select a model, upload your sequences, and click 'Run Prediction' to get started. 
                               Check the ", tags$b("Help"), " tab for detailed instructions.")
                      ),
                      
                      tags$h4(em("Instructions:", style = "color:darkblue")),
                      
                      # Dynamic instructions based on model type
                      conditionalPanel(
                        condition = "input.model_type == 'single'",
                        tags$div(
                          style = "background-color: #f0f8ff; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
                          tags$h5(strong("Single-Gene Model (ORF5)"), style = "color: #2F4F4F;"),
                          tags$h5(strong("Outbreak Virus:"), style = "color: #8B0000;"),
                          tags$p("Upload ORF5 nucleotide sequence(s) from outbreak strains.", style = "margin-bottom: 10px;"),
                          tags$h5(strong("Vaccine/LVI Virus:"), style = "color: #000080;"),
                          tags$p("Upload ORF5 nucleotide sequence(s) from vaccine or live virus inoculation (LVI) strains, or use built-in vaccine sequences.", style = "margin-bottom: 10px;"),
                          tags$h5(strong("Requirements:"), style = "color: #2F4F4F;"),
                          tags$ul(
                            tags$li("FASTA format, ideally 603 nucleotides (200 amino acids)"),
                            tags$li("Sequences of different lengths will be aligned to VR2332"),
                            tags$li("Ambiguous nucleotides (N, R, Y, etc.) are accepted but excluded from analysis"),
                            tags$li("Sequences below 70% valid coverage will be rejected")
                          )
                        )
                      ),
                      
                      conditionalPanel(
                        condition = "input.model_type == 'multi'",
                        tags$div(
                          style = "background-color: #fff8f0; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
                          tags$h5(strong("Multi-Gene Model (ORF2-ORF7)"), style = "color: #2F4F4F;"),
                          tags$h5(strong("Outbreak Virus:"), style = "color: #8B0000;"),
                          tags$p("Upload nucleotide sequence(s) spanning ORF2-ORF7 (structural proteins).", style = "margin-bottom: 10px;"),
                          tags$h5(strong("Vaccine/LVI Virus:"), style = "color: #000080;"),
                          tags$p("Upload ORF2-ORF7 sequence(s) or use built-in vaccine sequences.", style = "margin-bottom: 10px;"),
                          tags$h5(strong("Requirements:"), style = "color: #2F4F4F;"),
                          tags$ul(
                            tags$li("FASTA format, ideally 3188 nucleotides"),
                            tags$li("All sequences will be aligned to VR2332"),
                            tags$li("Ambiguous nucleotides are accepted but excluded from analysis"),
                            tags$li("Sequences below 70% coverage will be rejected")
                          )
                        )
                      ),
                      
                      # Progress indicator
                      conditionalPanel(
                        condition = "output.showProcessing",
                        tags$div(
                          style = "background-color: #fff3cd; border: 1px solid #ffeaa7; padding: 20px; border-radius: 5px; margin-bottom: 20px; text-align: center;",
                          tags$div(
                            style = "display: inline-flex; align-items: center; justify-content: center;",
                            tags$div(
                              style = "margin-right: 15px;",
                              tags$div(
                                class = "spinner-border text-warning",
                                role = "status",
                                style = "width: 2rem; height: 2rem;",
                                tags$span(class = "sr-only", "Loading...")
                              )
                            ),
                            tags$h4("Processing sequences, please wait...", style = "color: #856404; margin: 0;")
                          )
                        )
                      ),
                      
                      # Error messages
                      conditionalPanel(
                        condition = "output.showError",
                        tags$div(
                          style = "background-color: #f8d7da; border: 1px solid #f5c6cb; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
                          tags$h5("Error:", style = "color: #721c24; margin-bottom: 10px;"),
                          tags$pre(textOutput("errorMessage"), style = "color: #721c24; background: transparent; border: none; margin: 0; white-space: pre-wrap;")
                        )
                      ),
                      
                      # Success validation and results
                      conditionalPanel(condition = "output.showResults",
                                       tags$h4(em("Interpretation of Prediction:", style = "color:darkgreen")),
                                       uiOutput("interpretationText"),
                                       tags$h4(em("Validation Status:", style = "color:darkgreen")),
                                       verbatimTextOutput("validationMessage"),
                                       tags$h4(em("Prediction Summary:", style = "color:darkgoldenrod")),
                                       DT::dataTableOutput("summary_table")
                      )
               )
             )
           )
  ),
  tabPanel("Model Information", icon = icon("chart-line"),
           fluidPage(
             tags$h2("Model Performance and Technical Details"),
             tags$hr(),
             
             tags$div(
               style = "padding: 20px;",
               
               tags$h4("Single-Gene Model (ORF5)", style = "color: #2F4F4F;"),
               tags$div(
                 style = "background-color: #f0f8ff; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
                 tags$ul(
                   tags$li(tags$b("Algorithm:"), " LightGBM"),
                   tags$li(tags$b("Internal validation:"), " 93% accuracy"),
                   tags$li(tags$b("External validation:"), " 83% accuracy"),
                   tags$li(tags$b("Key features:"), " Comparative indices of residue-specific biochemical properties of amino acids within the GP5 ectodomain (particularly in hypervariable regions 1 and 2), ORF5 genetic distance, and variant-level comparisons")
                 )
               ),
               
               tags$h4("Multi-Gene Model (ORF2-ORF7)", style = "color: #2F4F4F;"),
               tags$div(
                 style = "background-color: #fff8f0; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
                 tags$ul(
                   tags$li(tags$b("Algorithm:"), " LightGBM"),
                   tags$li(tags$b("Internal validation:"), " 90% accuracy"),
                   tags$li(tags$b("External validation:"), " Not yet tested"),
                   tags$li(tags$b("Genes analyzed:"), " ORF2 (GP2), ORF3 (GP3), ORF4 (GP4), ORF5 (GP5), ORF6 (M), ORF7 (N)"),
                   tags$li(tags$b("Key features:"), " Comparative indices of residue-specific biochemical properties within the ectodomains of structural proteins (primarily GP2 and GP3), genetic distances of structural protein genes, and ORF5-based variant-level comparisons")
                 )
               ),
               
               tags$h4("Sequence Processing", style = "color: #2F4F4F;"),
               tags$div(
                 style = "background-color: #f8fff8; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
                 tags$ul(
                   tags$li("Automatic alignment to VR2332 reference strain"),
                   tags$li("Ambiguous nucleotides and non-translatable codons are excluded from feature calculation"),
                   tags$li("Missing features are filled using median values from internal cross-neutralization data"),
                   tags$li("Sequences below 70% valid coverage are rejected")
                 )
               ),
               
               tags$h4("Variant Classification", style = "color: #2F4F4F;"),
               tags$div(
                 style = "background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
                 tags$p("PRRSV-2 variants are automatically classified using ORF5 sequences."),
                 tags$ul(
                   tags$li("Classification method: ", tags$a(href = "https://github.com/kvanderwaal/prrsv2_classification", "Github page of VanderWaal Lab PRRSV-2 classifier", target = "_blank")),
                   tags$li("Variant-level relationships between outbreak and vaccine strains are used as prediction features")
                 )
               ),
               
               tags$hr(),
               tags$h4("Limitations"),
               tags$img(src = "XRpredinfo.png", width = "100%", alt = "Limitations")
             )
           )
  ),
  tabPanel("Help", icon = icon("question"),
           fluidPage(
             tags$h2("Help Information"),
             tags$hr(),
             
             tags$h4("Quick Start:", style = "color: #2F4F4F;"),
             tags$ol(
               tags$li("Select prediction model (Single-Gene or Multi-Gene)"),
               tags$li("Choose input mode (outbreak only, or outbreak + vaccine/LVI)"),
               tags$li("Upload FASTA file or paste sequences"),
               tags$li("Click 'Run Prediction'"),
               tags$li("Click 'Download Summary Table' to download results as CSV"),
               tags$li("Click 'Download Log File' to download detailed process logs and error reports, particularly when a prediction fails")
             ),
             tags$hr(),
             
             tags$h4("Sequence Requirements:", style = "color: #2F4F4F;"),
             tags$div(
               style = "background-color: #f5f5f5; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
               tags$p(tags$b("Single-Gene Model:")),
               tags$ul(
                 tags$li("ORF5 nucleotide sequences (ideally 603 nt)"),
                 tags$li("Aligned to VR2332 if different length"),
                 tags$li("Minimum 70% valid coverage required")
               ),
               tags$p(tags$b("Multi-Gene Model:")),
               tags$ul(
                 tags$li("ORF2-ORF7 nucleotide sequences (ideally 3188 nt)"),
                 tags$li("Aligned to VR2332 for all cases"),
                 tags$li("Minimum 70% coverage required"),
                 tags$li("Gene positions: ORF2 (1-771), ORF3 (624-1388), ORF4 (1169-1705), ORF5 (1716-2318), ORF6 (2303-2827), ORF7 (2817-3188)")
               ),
               tags$p(tags$b("All Models:")),
               tags$ul(
                 tags$li("FASTA format required"),
                 tags$li("Ambiguous nucleotides (N, R, Y, etc.) are handled but excluded from calculations"),
                 tags$li("RNA sequences (containing U) are automatically converted to DNA (Uâ†’T)")
               )
             ),
             tags$hr(),
             
             tags$h4("Built-in Vaccine Strains:", style = "color: #2F4F4F;"),
             tags$p("When using 'Upload outbreak virus sequence(s) only' mode, predictions are made against the following built-in vaccine strains:"),
             tags$ul(
               tags$li("Fostera (Variant 8C.1)"),
               tags$li("Ingelvac ATP (Variant 8A.1)"),
               tags$li("VR2332 (Variant 5A.1)"),
               tags$li("Ingelvac MLV (Variant 5A.1)"),
               tags$li("PrimePac (Variant 7.1)"),
               tags$li("Prevacent (Variant 1D.2)")
             ),
             tags$hr(),
             
             tags$h4("Output Interpretation:", style = "color: #2F4F4F;"),
             tags$ul(
               tags$li(tags$b("High:"), " The outbreak virus is likely to be neutralized by the vaccine/LVI serum (predicted titer above average)"),
               tags$li(tags$b("Low:"), " The outbreak virus is not likely to be neutralized (predicted titer below average)")
             ),
             tags$hr(),
             
             tags$h4("Troubleshooting:", style = "color: #2F4F4F;"),
             tags$ul(
               tags$li("If sequences are rejected due to low coverage, check for excessive gaps or ambiguous nucleotides"),
               tags$li("Ensure sequences are in proper FASTA format (header line starting with '>' followed by sequence)"),
               tags$li("For multi-gene model, ensure your sequence covers the full ORF2-ORF7 region"),
               tags$li("Click 'Download Log File' for detailed processing messages and error information")
             )
           )
  ),
  tabPanel("About", icon = icon("info-circle"),
           fluidPage(
             tags$h2("About PRRSLoom-Neutralization Predictor"),
             tags$hr(),
             
             tags$div(
               style = "padding: 20px;",
               
               tags$h4("Purpose", style = "color: #2F4F4F;"),
               tags$p("This tool predicts the neutralization potential of PRRSV-2 outbreak viruses by vaccine or live virus inoculation (LVI) sera. It helps assess whether existing immunity from vaccination or prior infection is likely to provide cross-protection against emerging outbreak strains."),
               
               tags$hr(),
               tags$h4("How It Works", style = "color: #2F4F4F;"),
               tags$p("The predictor compares genetic features between outbreak virus sequences and vaccine/LVI virus sequences to estimate neutralization titers. Machine learning models trained on experimental neutralization assay data generate predictions based on sequence-derived features including amino acid distances, glycosylation patterns, and structural protein properties."),
               
               tags$hr(),
               tags$h4("Development Team", style = "color: #2F4F4F;"),
               tags$p("This tool was developed and is maintained by:"),
               tags$ul(
                 tags$li("Nakarin Pamornchainavakul, DVM, PhD"),
                 tags$li("Kimberly VanderWaal, PhD")
               ),
               tags$p("University of Minnesota, College of Veterinary Medicine"),
               
               tags$hr(),
               tags$h4("Funding", style = "color: #2F4F4F;"),
               tags$p("This project is funded by the U.S. Department of Agriculture, National Institute of Food and Agriculture, Data Science for Food and Agricultural Systems Program (grant number 2023-67021-40018)."),
               
               tags$hr(),
               tags$h4("Citation", style = "color: #2F4F4F;"),
               tags$p("If you use this tool in your research, please cite:"),
               tags$div(
                 style = "background-color: #f5f5f5; padding: 15px; border-radius: 5px;",
                 tags$p(tags$em("[Citation information to be added upon publication]"))
               ),
               
               tags$hr(),
               tags$h4("Contact", style = "color: #2F4F4F;"),
               tags$p("For questions, feedback, or bug reports, please contact:"),
               tags$ul(
                 tags$li("Nakarin Pamornchainavakul: ", tags$a(href = "mailto:pamor001@umn.edu", "pamor001@umn.edu")),
                 tags$li("Kimberly VanderWaal: ", tags$a(href = "mailto:kvw@umn.edu", "kvw@umn.edu"))
               ),
               
               tags$hr(),
               tags$h4("Disclaimer", style = "color: #2F4F4F;"),
               tags$p(style = "font-size: 90%; color: #666;", 
                      "This tool provides predictions based on computational models and should be used as a screening aid. 
                       Predictions are not a substitute for laboratory neutralization assays. 
                       The accuracy of predictions may vary depending on the genetic diversity of input sequences 
                       relative to the training data. Users should interpret results in the context of their specific situation 
                       and consider confirmatory testing for critical decisions.")
             )
           )
  ),
  tabPanel("Go to PRRSLoom-Variants", icon = icon("external-link-alt"),
           value = "goto_variants",
           fluidPage(
             tags$div(
               style = "padding: 50px; text-align: center;",
               tags$h2("Redirecting to PRRSLoom-Variants..."),
               tags$p(style = "font-size: 120%; margin-top: 30px;", 
                      "You will be redirected to PRRSLoom-Variants in a new tab."),
               tags$p(style = "margin-top: 20px;",
                      tags$a(href = "https://stemma.shinyapps.io/PRRSLoom-variants/", 
                             target = "_blank",
                             "Click here if you are not automatically redirected",
                             style = "font-size: 110%; color: #0066cc;"))
             )
           )
  )
)

server <- function(input, output, session) {
  options(shiny.maxRequestSize = 1600 * 1024^2)
  
  # Initialize reactive values
  values <- reactiveValues(
    showResults = FALSE,
    showProcessing = FALSE,
    showError = FALSE,
    errorMessage = "",
    validationMessage = "",
    predictionTable = NULL
  )
  
  # ---- Begin: session logging setup ----
  # Create a session-specific log file and redirect console output/messages to it
  session_log_file <- tempfile(pattern = "XRpred_log_", fileext = ".txt")
  # open a connection to append to the file
  session_log_con <- file(session_log_file, open = "a")
  
  # Try to redirect standard output and messages to the log file.
  # We wrap in tryCatch to avoid fatal errors if sink fails.
  tryCatch({
    sink(session_log_con, type = "output")
  }, error = function(e) {
    # If sink fails, write a simple note to original console
    message("Warning: unable to sink output to session log:", e$message)
  })
  
  tryCatch({
    sink(session_log_con, type = "message")
  }, error = function(e) {
    message("Warning: unable to sink messages to session log:", e$message)
  })
  
  # Store log info in session$userData so other code (download handler, session end) can access it
  session$userData$xrpred_log_file <- session_log_file
  session$userData$xrpred_log_con <- session_log_con
  
  # Ensure we restore sinks and close the connection when the session ends
  session$onSessionEnded(function() {
    # Try to restore message sink and output sink (will do nothing if already restored)
    try(sink(NULL, type = "message"), silent = TRUE)
    try(sink(NULL, type = "output"), silent = TRUE)
    # Close connection
    try(close(session_log_con), silent = TRUE)
  })
  # ---- End: session logging setup ----
  
  # Redirect to PRRSLoom-Variants when tab is clicked
  observeEvent(input$nav, {
    if (input$nav == "goto_variants") {
      runjs('window.open("https://stemma.shinyapps.io/PRRSLoom-variants/", "_blank");')
      # Switch back to Home tab after opening
      updateNavbarPage(session, "nav", selected = "Home")
    }
  })
  
  # Control UI state displays
  output$showProcessing <- reactive({ values$showProcessing })
  outputOptions(output, "showProcessing", suspendWhenHidden = FALSE)
  
  output$showError <- reactive({ values$showError })
  outputOptions(output, "showError", suspendWhenHidden = FALSE)
  
  output$showResults <- reactive({ values$showResults })
  outputOptions(output, "showResults", suspendWhenHidden = FALSE)
  
  output$errorMessage <- renderText({ values$errorMessage })
  output$validationMessage <- renderText({ values$validationMessage })
  
  # Dynamic interpretation text based on model type
  output$interpretationText <- renderUI({
    if (input$model_type == "single") {
      tags$div(
        style = "background-color: #f8fff8; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
        tags$p(strong("High:"), " The outbreak virus is likely to be neutralized by the vaccine/LVI serum (predicted titer above average)."),
        tags$p(strong("Low:"), " The outbreak virus is unlikely to be neutralized (predicted titer below average)."),
        tags$hr(),
        tags$p(style = "font-size: 90%; color: #666;", 
               "Prediction based on a LightGBM model trained on GP5 ectodomain and sequence-derived features. Internal accuracy: 93%. External validation accuracy: 83%.")
      )
    } else {
      tags$div(
        style = "background-color: #f8fff8; padding: 15px; border-radius: 5px; margin-bottom: 20px;",
        tags$p(strong("High:"), " The outbreak virus is likely to be neutralized by the vaccine/LVI serum (predicted titer above average)."),
        tags$p(strong("Low:"), " The outbreak virus is unlikely to be neutralized (predicted titer below average)."),
        tags$hr(),
        tags$p(style = "font-size: 90%; color: #666;", 
               "Prediction based on LightGBM model using features from all structural protein genes (ORF2-ORF7). Internal accuracy: 90%.")
      )
    }
  })
  
  # ===== ALL HELPER FUNCTIONS =====
  # Load GitHub variant classification model for ORF5
  load_github_variant_model <- function() {
    tryCatch({
      source(url("https://github.com/kvanderwaal/prrsv2_classification/raw/main/rf10v.predict.fun.R"))
      load(url("https://github.com/kvanderwaal/prrsv2_classification/raw/main/model.Rdata"))
      return(TRUE)
    }, error = function(e) {
      warning("Failed to load GitHub variant model: ", e$message)
      return(FALSE)
    })
  }
  
  # Extract individual genes from 3188 nt sequence
  extract_genes <- function(full_seq) {
    genes_nt <- list()
    for (gene_name in names(gene_positions)) {
      pos <- gene_positions[[gene_name]]
      genes_nt[[gene_name]] <- substr(full_seq, pos[1], pos[2])
    }
    return(genes_nt)
  }
  
  # Diagnostic function to check sequences and filter out problematic ones
  check_and_filter_sequences <- function(seqs_3188, seq_type = "viral") {
    valid_seqs <- list()
    invalid_seqs <- list()
    diagnostic_messages <- c()
    
    for (seq_name in names(seqs_3188)) {
      full_seq <- as.character(seqs_3188[[seq_name]])
      seq_issues <- c()
      gene_issues <- list()
      
      # Check length
      if (nchar(full_seq) != 3188) {
        seq_issues <- c(seq_issues, paste0("Length ", nchar(full_seq), " nt (expected 3188)"))
      }
      
      # Check for ambiguous nucleotides
      ambig <- gregexpr("[^ATGC]", full_seq, ignore.case = TRUE)[[1]]
      if (ambig[1] != -1) {
        ambig_chars <- unique(strsplit(gsub("[ATGC]", "", full_seq), "")[[1]])
        seq_issues <- c(seq_issues, paste0("Ambiguous nucleotides: ", paste(ambig_chars, collapse=", ")))
      }
      
      # Extract and check each gene
      genes_nt <- extract_genes(full_seq)
      all_genes_ok <- TRUE
      
      for (gene_name in names(genes_nt)) {
        gene_seq <- genes_nt[[gene_name]]
        gene_len <- nchar(gene_seq)
        
        # Check if divisible by 3
        if (gene_len %% 3 != 0) {
          gene_issues[[gene_name]] <- paste0("Length ", gene_len, " not divisible by 3")
          all_genes_ok <- FALSE
          next
        }
        
        # Translate and check for premature stops
        gene_dna <- DNAString(gene_seq)
        gene_aa <- translate(gene_dna)
        aa_char <- as.character(gene_aa)
        aa_len <- nchar(aa_char)
        
        if (aa_len > 1) {
          first_part <- substr(aa_char, 1, aa_len - 1)
          stop_positions <- gregexpr("\\*", first_part)[[1]]
          
          if (stop_positions[1] != -1) {
            gene_issues[[gene_name]] <- paste0("PREMATURE STOP at AA position(s): ", 
                                               paste(stop_positions, collapse=", "))
            all_genes_ok <- FALSE
          }
        }
      }
      
      # Compile issues for this sequence
      if (length(seq_issues) > 0 || length(gene_issues) > 0) {
        invalid_seqs[[seq_name]] <- list(seq_issues = seq_issues, gene_issues = gene_issues)
        
        # Build diagnostic message
        msg <- paste0("--- Sequence: ", seq_name, " ---\n")
        if (length(seq_issues) > 0) {
          msg <- paste0(msg, "  Sequence-level issues:\n")
          for (issue in seq_issues) {
            msg <- paste0(msg, "    âœ— ", issue, "\n")
          }
        }
        if (length(gene_issues) > 0) {
          for (gene_name in names(gene_issues)) {
            pos_range <- gene_positions[[gene_name]]
            msg <- paste0(msg, "  ", gene_name, "(", pos_range[1], "-", pos_range[2], "): âœ— ", 
                          gene_issues[[gene_name]], "\n")
          }
        }
        diagnostic_messages <- c(diagnostic_messages, msg)
      } else {
        valid_seqs[[seq_name]] <- seqs_3188[[seq_name]]
      }
    }
    
    return(list(
      valid_seqs = DNAStringSet(unlist(valid_seqs)),
      invalid_seqs = invalid_seqs,
      diagnostic_messages = diagnostic_messages
    ))
  }
  
  # Read and process multi-gene sequences with flexible alignment
  read_and_process_3188 <- function(file, text, seq_type = "viral") {
    print(paste("=== read_and_process_3188 called for", seq_type, "==="))
    
    raw_seqs <- NULL
    
    # === STEP A: Read raw sequences and convert U to T ===
    if (!is.null(file)) {
      print("Reading from file...")
      
      # Read raw file and check for U nucleotides
      raw_lines <- readLines(file$datapath)
      
      if (any(grepl("[Uu]", raw_lines))) {
        u_total <- sum(nchar(gsub("[^Uu]", "", raw_lines)))
        print(paste("=== DETECTED", u_total, "U nucleotides (RNA sequences) - converting to T (DNA) ==="))
        raw_lines <- gsub("[Uu]", "T", raw_lines)
        print("=== All U nucleotides converted to T ===")
        
        # Write corrected sequence to temp file
        temp_file <- tempfile(fileext = ".fasta")
        writeLines(raw_lines, temp_file)
        
        raw_seqs <- tryCatch({
          seqs <- readDNAStringSet(temp_file)
          DNAStringSet(gsub("-", "", as.character(seqs)))
        }, error = function(e) {
          stop(paste("Failed to read FASTA file:", e$message))
        }, finally = {
          unlink(temp_file)
        })
      } else {
        raw_seqs <- tryCatch({
          seqs <- readDNAStringSet(file$datapath)
          DNAStringSet(gsub("-", "", as.character(seqs)))
        }, error = function(e) {
          stop(paste("Failed to read FASTA file:", e$message))
        })
      }
      print(paste("Read", length(raw_seqs), "sequences from file"))
      
    } else if (nchar(trimws(text)) > 0) {
      print("Reading from pasted text...")
      text <- trimws(text)
      
      # Check for U nucleotides in pasted text
      if (grepl("[Uu]", text)) {
        u_total <- nchar(gsub("[^Uu]", "", text))
        print(paste("=== DETECTED", u_total, "U nucleotides (RNA sequences) - converting to T (DNA) ==="))
        text <- gsub("[Uu]", "T", text)
        print("=== All U nucleotides converted to T ===")
      }
      
      lines <- strsplit(text, "\n")[[1]]
      lines <- lines[nchar(trimws(lines)) > 0]
      has_headers <- any(grepl("^>", lines))
      
      if (!has_headers) {
        fasta_lines <- character()
        for (i in seq_along(lines)) {
          current_seq <- trimws(lines[i])
          suffix_letter <- LETTERS[((i - 1) %% 26) + 1]
          if (i > 26) suffix_letter <- paste0(suffix_letter, ceiling(i / 26))
          
          if (seq_type == "viral") {
            seq_name <- paste0("outbreak_virus_", suffix_letter)
          } else {
            seq_name <- paste0("vaccine_LVI_virus_", suffix_letter)
          }
          fasta_lines <- c(fasta_lines, paste0(">", seq_name), current_seq)
        }
        text <- paste(fasta_lines, collapse = "\n")
      }
      
      temp_file <- tempfile(fileext = ".fasta")
      writeLines(text, temp_file)
      raw_seqs <- tryCatch({
        seqs <- readDNAStringSet(temp_file)
        DNAStringSet(gsub("-", "", as.character(seqs)))
      }, error = function(e) {
        stop(paste("Failed to parse FASTA text:", e$message))
      }, finally = {
        unlink(temp_file)
      })
      print(paste("Read", length(raw_seqs), "sequences from text"))
    }
    
    # === STEP B: Align all sequences to VR2332 reference ===
    print("=== Aligning all sequences to VR2332 reference ===")
    
    aligned_seqs <- list()
    rejected_seqs <- character()
    
    for (seq_name in names(raw_seqs)) {
      seq_str <- as.character(raw_seqs[[seq_name]])
      
      # Align to VR2332 reference
      align_result <- align_to_vr2332_3188(seq_str, seq_name)
      
      # Check nucleotide coverage threshold (70%)
      if (align_result$coverage < 0.70) {
        print(paste("REJECTED:", seq_name, "- nucleotide coverage too low (", 
                    round(align_result$coverage * 100, 1), "%)"))
        rejected_seqs <- c(rejected_seqs, 
                           paste0("Sequence '", seq_name, "' is invalid due to low nucleotide coverage (", 
                                  round(align_result$coverage * 100, 1), "%)"))
        next
      }
      
      print(paste("ACCEPTED:", seq_name, "- coverage:", round(align_result$coverage * 100, 1), "%"))
      aligned_seqs[[seq_name]] <- align_result$aligned_seq
    }
    
    # Check if any sequences remain
    if (length(aligned_seqs) == 0) {
      print("No valid sequences remaining after alignment!")
      stop("No valid sequences found. All sequences have insufficient coverage:\n\n", 
           paste(rejected_seqs, collapse = "\n"))
    }
    
    print(paste("=== Alignment complete:", length(aligned_seqs), "sequences passed,", 
                length(rejected_seqs), "rejected ==="))
    
    # === STEP C: Extract genes and translate ===
    print("=== Extracting genes and translating ===")
    
    all_genes_nt <- list()
    all_genes_aa <- list()
    all_valid_positions <- list()
    
    for (seq_name in names(aligned_seqs)) {
      full_seq <- aligned_seqs[[seq_name]]
      print(paste("Processing genes for:", seq_name))
      
      genes_nt <- list()
      genes_aa <- list()
      gene_valid_positions <- list()
      
      for (gene_name in names(gene_positions)) {
        pos <- gene_positions[[gene_name]]
        gene_nt <- substr(full_seq, pos[1], pos[2])
        genes_nt[[gene_name]] <- gene_nt
        
        # Translate with tracking
        trans_result <- translate_gene_with_tracking(gene_nt, gene_name)
        genes_aa[[gene_name]] <- trans_result$aa_seq
        gene_valid_positions[[gene_name]] <- trans_result$valid_positions
        
        valid_count <- sum(trans_result$valid_positions)
        total_count <- length(trans_result$valid_positions)
        print(paste("  ", gene_name, ":", valid_count, "/", total_count, "valid AA positions (",
                    round(trans_result$coverage * 100, 1), "%)"))
      }
      
      all_genes_nt[[seq_name]] <- genes_nt
      all_genes_aa[[seq_name]] <- genes_aa
      all_valid_positions[[seq_name]] <- gene_valid_positions
    }
    
    # Build warning message
    warning_msg <- ""
    if (length(rejected_seqs) > 0) {
      warning_msg <- paste0(
        "WARNING: The following sequence(s) were removed due to low coverage:\n\n",
        paste(rejected_seqs, collapse = "\n"),
        "\n\nNumber of sequences removed: ", length(rejected_seqs), "\n",
        "Number of valid sequences: ", length(aligned_seqs), "\n"
      )
    }
    
    print(paste("=== read_and_process_3188 finished ==="))
    print(paste("Returning", length(all_genes_aa), "sequences"))
    
    return(list(
      genes_nt = all_genes_nt, 
      genes_aa = all_genes_aa,
      valid_positions = all_valid_positions,
      warning_msg = warning_msg,
      rejected_seqs = rejected_seqs
    ))
  }
  
  # Prepare vaccine sequences
  vaccine_seqs <- reactive({
    if (input$inputmode == "viral_only") {
      # Extract genes from built-in vaccine sequences
      all_genes_nt <- list()
      all_genes_aa <- list()
      
      for (vaccine_name in names(vaccine_full_nt_seqs)) {
        full_seq <- vaccine_full_nt_seqs[[vaccine_name]]
        genes_nt <- extract_genes(full_seq)
        genes_aa <- list()
        
        for (gene_name in names(genes_nt)) {
          gene_nt_seq <- DNAString(genes_nt[[gene_name]])
          gene_aa_seq <- translate(gene_nt_seq)
          aa_char <- as.character(gene_aa_seq)
          genes_aa[[gene_name]] <- substr(aa_char, 1, nchar(aa_char) - 1)
        }
        
        all_genes_nt[[vaccine_name]] <- genes_nt
        all_genes_aa[[vaccine_name]] <- genes_aa
      }
      
      return(list(genes_nt = all_genes_nt, genes_aa = all_genes_aa))
    } else {
      return(read_and_process_3188(input$file_serum, input$fasta_serum, seq_type = "serum"))
    }
  })
  
  viral_seqs <- reactive({
    read_and_process_3188(input$file_viral, input$fasta_viral, seq_type = "viral")
  })
  
  # AA class mapping
  aa_class_map <- list(
    nonpolar = c("A", "V", "L", "I", "M", "F", "W", "P", "G"),
    polar = c("S", "T", "N", "Q", "Y", "C"),
    acidic = c("D", "E"),
    basic = c("K", "R", "H")
  )
  
  legal_aa <- unique(unlist(aa_class_map))
  legal_aa <- c(legal_aa, "-")
  
  get_aa_class <- function(aa) {
    if (is.na(aa) || aa == "-" || aa %in% c("X", "*", "?")) return("gap")
    for (class in names(aa_class_map)) {
      if (!is.na(aa) && aa %in% aa_class_map[[class]]) return(class)
    }
    return("unknown")
  }
  
  # Hamming distance
  hamming_distance <- function(seq1, seq2) {
    if (length(seq1) != length(seq2)) return(NA_real_)
    valid_pos <- seq1 != "-" & seq2 != "-" & !is.na(seq1) & !is.na(seq2)
    total_valid <- sum(valid_pos)
    if (total_valid == 0) return(NA_real_)
    mismatches <- sum(seq1[valid_pos] != seq2[valid_pos])
    return(mismatches / total_valid)
  }
  
  # Find glycosylation sites
  find_glyco_sites <- function(seq_vec) {
    aa_seq <- paste(seq_vec, collapse = "")
    matches <- str_locate_all(aa_seq, "N[^P][ST]")[[1]]
    return(if (nrow(matches) > 0) matches[,1] else integer(0))
  }
  
  # Nucleotide distance calculation
  calculate_nt_distance <- function(seq1, seq2, model = "K80") {
    tryCatch({
      s1 <- as.character(seq1)
      s2 <- as.character(seq2)
      if (nchar(s1) != nchar(s2)) return(NA_real_)
      
      temp_file <- tempfile(fileext = ".fasta")
      writeLines(c(">seq1", s1, ">seq2", s2), temp_file)
      
      seqs <- read.dna(temp_file, format = "fasta")
      dist_mat <- dist.dna(seqs, model = model, pairwise.deletion = TRUE)
      unlink(temp_file)
      
      return(as.numeric(dist_mat[1]))
    }, error = function(e) {
      return(NA_real_)
    })
  }
  
  # AAindex features
  data(aaindex)
  aaindex_selection <- c(
    "KYTJ820101", "CHOC760101", "BHAR880101", "CHOP780203", "ZIMJ680104", "KLEP840101"
  )
  aa_shortnames <- c("hydro", "surf", "flex", "btprop", "pI", "charge")
  aa_3to1 <- c(
    Ala = "A", Arg = "R", Asn = "N", Asp = "D", Cys = "C",
    Gln = "Q", Glu = "E", Gly = "G", His = "H", Ile = "I",
    Leu = "L", Lys = "K", Met = "M", Phe = "F", Pro = "P",
    Ser = "S", Thr = "T", Trp = "W", Tyr = "Y", Val = "V"
  )
  
  aa_feature_map <- setNames(vector("list", length(aaindex_selection)), aa_shortnames)
  for (i in seq_along(aaindex)) {
    acc <- aaindex[[i]]$H
    if (acc %in% aaindex_selection) {
      shortname <- aa_shortnames[match(acc, aaindex_selection)]
      raw_vals <- aaindex[[i]]$I
      one_letter_vals <- setNames(as.numeric(raw_vals), aa_3to1[names(raw_vals)])
      aa_feature_map[[shortname]] <- one_letter_vals
    }
  }
  
  # Load LightGBM model
  load_lightgbm_model <- function(filepath) {
    tryCatch({
      model <- lgb.load(filepath)
      return(model)
    }, error = function(e) {
      stop(paste("Failed to load LightGBM model:", e$message))
    })
  }
  
  # Predict variants using GitHub model (ORF5 only)
  predict_variants <- function(orf5_nt_seqs, use_github = TRUE) {
    variant_assignments <- list()
    # Coerce input into a named character vector in a robust way
    seqs_char <- NULL
    try({
      if (inherits(orf5_nt_seqs, "DNAStringSet") || inherits(orf5_nt_seqs, "XStringSet")) {
        seqs_char <- as.character(orf5_nt_seqs)
        names(seqs_char) <- names(orf5_nt_seqs)
      } else if (is.list(orf5_nt_seqs)) {
        # list of sequences (possibly named)
        seqs_char <- unlist(orf5_nt_seqs, use.names = FALSE)
        # try to recover names from list elements; if the list is named, use those names
        if (!is.null(names(orf5_nt_seqs))) {
          # If elements are atomic strings, their order corresponds to list names
          names(seqs_char) <- rep(names(orf5_nt_seqs), times = vapply(orf5_nt_seqs, length, 1))
        } else {
          # fallback: if unlist produced names (e.g. nested named vectors), use them
          u_names <- names(unlist(orf5_nt_seqs))
          if (!is.null(u_names) && length(u_names) == length(seqs_char)) {
            names(seqs_char) <- u_names
          }
        }
      } else {
        # atomic vector / character vector
        seqs_char <- as.character(orf5_nt_seqs)
        if (is.null(names(seqs_char))) names(seqs_char) <- paste0("seq", seq_along(seqs_char))
      }
    }, silent = TRUE)
    
    # Ensure we have a character vector and names of same length
    if (is.null(seqs_char) || length(seqs_char) == 0) {
      # nothing to predict
      return(list())
    }
    if (is.null(names(seqs_char)) || length(names(seqs_char)) != length(seqs_char)) {
      names(seqs_char) <- paste0("seq", seq_along(seqs_char))
    }
    
    if (use_github && load_github_variant_model()) {
      temp_file <- tempfile(fileext = ".fasta")
      tryCatch({
        orf5_dna <- Biostrings::DNAStringSet(seqs_char)
        # write FASTA
        Biostrings::writeXStringSet(orf5_dna, temp_file)
        # read alignment and call remote prediction functions
        align_data <- read.alignment(temp_file, format = "fasta")
        predictions <- make.predict(al.new = align_data)
        if (is.data.frame(predictions) && nrow(predictions) > 0 && "SequenceName" %in% colnames(predictions)) {
          for (i in seq_len(nrow(predictions))) {
            seq_name <- as.character(predictions$SequenceName[i])
            variant <- as.character(predictions$assign.final[i])
            variant_assignments[[seq_name]] <- variant
          }
        }
      }, error = function(e) {
        warning("GitHub variant prediction failed: ", e$message)
        # mark that github prediction failed (fall back further down)
      }, finally = {
        if (file.exists(temp_file)) unlink(temp_file)
      })
    }
    
    # Fallback: ensure every input sequence gets an assignment
    for (seq_name in names(seqs_char)) {
      if (!seq_name %in% names(variant_assignments)) {
        if (seq_name %in% names(vaccine_variants)) {
          variant_assignments[[seq_name]] <- vaccine_variants[[seq_name]]
        } else {
          variant_assignments[[seq_name]] <- "unclassified"
        }
      }
    }
    
    return(variant_assignments)
  }
  
  # Extract features for all genes with valid position tracking
  extract_all_gene_features <- function(virus_id, serum_id, virus_genes_aa, serum_genes_aa,
                                        virus_genes_nt, serum_genes_nt, 
                                        all_glyco_sites, variant_viral, variant_serum,
                                        virus_valid_positions = NULL, serum_valid_positions = NULL) {
    features <- list()
    
    # Variant relationship features (from ORF5)
    if (!is.null(variant_viral) && !is.null(variant_serum) && 
        virus_id %in% names(variant_viral) && serum_id %in% names(variant_serum)) {
      
      virus_var <- variant_viral[[virus_id]]
      serum_var <- variant_serum[[serum_id]]
      
      serum_main <- str_extract(serum_var, "^[0-9]+[A-Z]")
      viral_main <- str_extract(virus_var, "^[0-9]+[A-Z]")
      serum_sub <- str_extract(serum_var, "(?<=\\.)[^-]+")
      viral_sub <- str_extract(virus_var, "(?<=\\.)[^-]+")
      serum_num <- str_extract(serum_var, "^[0-9]+")
      viral_num <- str_extract(virus_var, "^[0-9]+")
      
      features$diff_L <- 0L
      features$same_L <- 0L
      features$same_SL <- 0L
      features$samevar <- 0L
      
      if (!is.na(serum_main) && !is.na(viral_main) && !is.na(serum_num) && !is.na(viral_num)) {
        if (serum_var == virus_var) {
          features$samevar <- 1L
        } else if (serum_main == viral_main) {
          features$same_SL <- 1L
        } else if (serum_num == viral_num && serum_main != viral_main) {
          features$same_L <- 1L
        } else if (serum_num != viral_num) {
          features$diff_L <- 1L
        } else {
          features$diff_L <- 1L
        }
      } else {
        features$diff_L <- 1L
      }
    } else {
      features$diff_L <- 1L
      features$same_L <- 0L
      features$same_SL <- 0L
      features$samevar <- 0L
    }
    
    # Process each gene
    for (gene_name in names(gene_positions)) {
      virus_aa <- virus_genes_aa[[gene_name]]
      serum_aa <- serum_genes_aa[[gene_name]]
      virus_nt <- virus_genes_nt[[gene_name]]
      serum_nt <- serum_genes_nt[[gene_name]]
      
      virus_seq_vec <- strsplit(virus_aa, "")[[1]]
      serum_seq_vec <- strsplit(serum_aa, "")[[1]]
      
      # Get valid positions for this gene
      virus_valid <- if (!is.null(virus_valid_positions) && gene_name %in% names(virus_valid_positions)) {
        virus_valid_positions[[gene_name]]
      } else {
        rep(TRUE, length(virus_seq_vec))
      }
      
      serum_valid <- if (!is.null(serum_valid_positions) && gene_name %in% names(serum_valid_positions)) {
        serum_valid_positions[[gene_name]]
      } else {
        rep(TRUE, length(serum_seq_vec))
      }
      
      # Ensure same length
      min_len <- min(length(virus_seq_vec), length(serum_seq_vec), length(virus_valid), length(serum_valid))
      virus_seq_vec <- virus_seq_vec[1:min_len]
      serum_seq_vec <- serum_seq_vec[1:min_len]
      virus_valid <- virus_valid[1:min_len]
      serum_valid <- serum_valid[1:min_len]
      
      # Both must be valid for a position to be used
      pair_valid <- virus_valid & serum_valid
      valid_indices <- which(pair_valid)
      
      # AA distance (only on valid positions)
      if (length(valid_indices) > 0) {
        features[[paste0(gene_name, "_aa_dist")]] <- hamming_distance(
          virus_seq_vec[valid_indices], serum_seq_vec[valid_indices]
        )
      } else {
        features[[paste0(gene_name, "_aa_dist")]] <- NA_real_
      }
      
      # Ectodomain AA distance
      if (gene_name %in% names(ectodomain_ranges)) {
        ecto_ranges <- ectodomain_ranges[[gene_name]]
        ecto_positions <- c()
        for (range in ecto_ranges) {
          ecto_positions <- c(ecto_positions, range[1]:range[2])
        }
        
        # Filter to valid positions within ectodomain
        ecto_valid <- ecto_positions[ecto_positions %in% valid_indices & ecto_positions <= min_len]
        
        if (length(ecto_valid) > 0) {
          features[[paste0(gene_name, "_ecto_aa_dist")]] <- hamming_distance(
            virus_seq_vec[ecto_valid], serum_seq_vec[ecto_valid]
          )
        } else {
          features[[paste0(gene_name, "_ecto_aa_dist")]] <- NA_real_
        }
      }
      
      # NT distance
      features[[paste0(gene_name, "_nt_dist")]] <- calculate_nt_distance(virus_nt, serum_nt)
      
      # Ectodomain NT distance
      if (gene_name %in% names(ectodomain_ranges)) {
        ecto_ranges <- ectodomain_ranges[[gene_name]]
        ecto_nt_positions <- c()
        for (range in ecto_ranges) {
          start_nt <- (range[1] - 1) * 3 + 1
          end_nt <- range[2] * 3
          ecto_nt_positions <- c(ecto_nt_positions, start_nt:end_nt)
        }
        
        if (length(ecto_nt_positions) > 0 && 
            nchar(virus_nt) >= max(ecto_nt_positions) && 
            nchar(serum_nt) >= max(ecto_nt_positions)) {
          virus_ecto_nt <- substr(virus_nt, min(ecto_nt_positions), max(ecto_nt_positions))
          serum_ecto_nt <- substr(serum_nt, min(ecto_nt_positions), max(ecto_nt_positions))
          features[[paste0(gene_name, "_ecto_nt_dist")]] <- calculate_nt_distance(virus_ecto_nt, serum_ecto_nt)
        } else {
          features[[paste0(gene_name, "_ecto_nt_dist")]] <- NA_real_
        }
      }
      
      # Glycosylation sites (only check valid positions)
      gene_glyco_sites <- all_glyco_sites[[gene_name]]
      
      for (site in gene_glyco_sites) {
        # Only create glyco features if the site position is valid in both sequences
        if (site <= min_len && (site + 2) <= min_len && 
            pair_valid[site] && pair_valid[min(site + 1, min_len)] && pair_valid[min(site + 2, min_len)]) {
          
          # Check if glycosylation pattern exists at this site
          virus_glyco <- find_glyco_sites(virus_seq_vec[pair_valid])
          serum_glyco <- find_glyco_sites(serum_seq_vec[pair_valid])
          
          v_gly <- as.integer(site %in% virus_glyco)
          s_gly <- as.integer(site %in% serum_glyco)
          features[[paste0(gene_name, "_nogly_", sprintf("%03d", site))]] <- as.integer(v_gly == 0 && s_gly == 0)
          features[[paste0(gene_name, "_gly_s_", sprintf("%03d", site))]] <- as.integer(v_gly == 0 && s_gly == 1)
          features[[paste0(gene_name, "_gly_v_", sprintf("%03d", site))]] <- as.integer(v_gly == 1 && s_gly == 0)
          features[[paste0(gene_name, "_gly_both_", sprintf("%03d", site))]] <- as.integer(v_gly == 1 && s_gly == 1)
        }
        # If position is not valid, features won't be created (will be imputed later)
      }
      
      # Position-specific features (only for valid positions)
      for (i in 1:min_len) {
        pos_str <- sprintf("%03d", i)
        
        if (pair_valid[i]) {
          vaa <- virus_seq_vec[i]
          saa <- serum_seq_vec[i]
          
          features[[paste0(gene_name, "_p", pos_str, "_same")]] <- as.integer(!is.na(vaa) && !is.na(saa) && vaa == saa)
          
          # AAindex features
          for (shortname in names(aa_feature_map)) {
            fmap <- aa_feature_map[[shortname]]
            val <- 0
            if (!is.na(vaa) && !is.na(saa) && vaa %in% names(fmap) && saa %in% names(fmap)) {
              val <- fmap[[saa]] - fmap[[vaa]]
            }
            features[[paste0(gene_name, "_p", pos_str, "_", shortname)]] <- val
          }
          
          # Amino acid class transitions
          from_class <- get_aa_class(saa)
          to_class <- get_aa_class(vaa)
          trans_key <- paste0(gene_name, "_p", pos_str, "_s_", from_class, "_v_", to_class)
          features[[trans_key]] <- as.integer((!is.na(vaa) && !is.na(saa)) && vaa != saa)
        }
        # If position is not valid, features won't be created (will be imputed later)
      }
    }
    
    return(features)
  }
  
  # ===== HELPER FUNCTIONS FOR FLEXIBLE SEQUENCE HANDLING =====
  
  # Reference sequence for alignment (VR2332 ORF5)
  vr2332_orf5_ref <- serum_nt_strains$VR2332
  
  # Reference sequence for multi-gene alignment (VR2332 full ORF2-ORF7, 3188 nt)
  vr2332_3188_ref <- vaccine_full_nt_seqs$VR2332
  
  # Align sequence to VR2332 reference and adjust to 603 nt
  align_to_vr2332 <- function(query_seq) {
    print(paste("=== align_to_vr2332 called ==="))
    print(paste("Input length:", nchar(as.character(query_seq))))
    
    tryCatch({
      query_str <- toupper(as.character(query_seq))
      query_str <- gsub("-", "", query_str)
      
      print(paste("Cleaned length:", nchar(query_str)))
      
      query_dna <- DNAString(query_str)
      ref_dna <- DNAString(vr2332_orf5_ref)
      
      # Perform global-local alignment
      alignment <- pwalign::pairwiseAlignment(
        pattern = query_dna,
        subject = ref_dna,
        type = "global-local"
      )
      
      print("Alignment completed")
      
      # Get alignment details
      subject_start <- pwalign::start(pwalign::subject(alignment))
      subject_end <- pwalign::end(pwalign::subject(alignment))
      
      print(paste("Subject start:", subject_start, "Subject end:", subject_end))
      
      aligned_pattern <- as.character(pwalign::alignedPattern(alignment))
      aligned_subject <- as.character(pwalign::alignedSubject(alignment))
      
      print(paste("Aligned pattern length:", nchar(aligned_pattern)))
      
      # Build result sequence of exactly 603 nt
      result_chars <- rep("-", 603)
      
      # Map aligned query to reference positions
      ref_pos <- subject_start
      pattern_chars <- strsplit(aligned_pattern, "")[[1]]
      subject_chars <- strsplit(aligned_subject, "")[[1]]
      
      for (i in seq_along(pattern_chars)) {
        if (subject_chars[i] != "-") {
          if (ref_pos >= 1 && ref_pos <= 603) {
            result_chars[ref_pos] <- pattern_chars[i]
          }
          ref_pos <- ref_pos + 1
        }
      }
      
      result <- paste(result_chars, collapse = "")
      print(paste("Result length:", nchar(result)))
      
      return(result)
    }, error = function(e) {
      print(paste("ERROR in align_to_vr2332:", e$message))
      # Fallback
      seq_str <- toupper(as.character(query_seq))
      seq_str <- gsub("-", "", seq_str)
      if (nchar(seq_str) > 603) {
        return(substr(seq_str, 1, 603))
      } else if (nchar(seq_str) < 603) {
        return(paste0(seq_str, paste(rep("-", 603 - nchar(seq_str)), collapse = "")))
      }
      return(seq_str)
    })
  }
  
  # Translate codon safely, returning NA for invalid codons
  safe_translate_codon <- function(codon) {
    codon <- toupper(codon)
    # Check for gaps or ambiguous nucleotides
    if (grepl("-", codon) || grepl("[^ATGC]", codon) || nchar(codon) != 3) {
      return(NA_character_)
    }
    tryCatch({
      aa <- as.character(Biostrings::translate(DNAString(codon)))
      if (aa == "*") {
        return(NA_character_)  # Stop codon treated as invalid for internal positions
      }
      return(aa)
    }, error = function(e) {
      return(NA_character_)
    })
  }
  
  # Format imputation summary for display
  format_imputation_summary <- function(seq_imputation_list, seq_type = "Outbreak Virus") {
    if (length(seq_imputation_list) == 0) {
      return(paste0(seq_type, " Sequences: No imputation needed (all positions valid)\n"))
    }
    
    msg <- paste0(seq_type, " Sequences:\n")
    for (seq_name in names(seq_imputation_list)) {
      info <- seq_imputation_list[[seq_name]]
      msg <- paste0(msg, 
                    "  - ", seq_name, ": ",
                    info$invalid_count, " invalid position(s) (",
                    round(100 - info$coverage * 100, 1), "% invalid), ",
                    info$affected_features, " feature(s) imputed\n")
    }
    return(msg)
  }
  
  # Translate 603 nt sequence to 200 AA with validity tracking
  translate_with_tracking <- function(nt_seq) {
    nt_seq <- toupper(as.character(nt_seq))
    print(paste("=== translate_with_tracking called, input length:", nchar(nt_seq)))
    
    aa_seq <- character(200)
    valid_positions <- logical(200)
    
    for (i in 1:200) {
      start_pos <- (i - 1) * 3 + 1
      codon <- substr(nt_seq, start_pos, start_pos + 2)
      aa <- safe_translate_codon(codon)
      
      if (!is.na(aa)) {
        aa_seq[i] <- aa
        valid_positions[i] <- TRUE
      } else {
        aa_seq[i] <- "X"  # Placeholder for invalid
        valid_positions[i] <- FALSE
      }
    }
    
    coverage <- sum(valid_positions) / 200
    invalid_count <- sum(!valid_positions)
    print(paste("Coverage:", round(coverage * 100, 1), "%, Valid positions:", sum(valid_positions), ", Invalid positions:", invalid_count))
    
    return(list(
      aa_seq = paste(aa_seq, collapse = ""),
      valid_positions = valid_positions,
      coverage = coverage,
      invalid_count = invalid_count
    ))
  }
  
  # ===== END HELPER FUNCTIONS =====
  
  # ===== HELPER FUNCTIONS FOR FLEXIBLE MULTI-GENE SEQUENCE HANDLING =====
  
  # Align sequence to VR2332 3188 nt reference
  align_to_vr2332_3188 <- function(query_seq, seq_name = "unknown") {
    print(paste("=== align_to_vr2332_3188 called for:", seq_name, "==="))
    print(paste("Input length:", nchar(as.character(query_seq))))
    
    tryCatch({
      query_str <- toupper(as.character(query_seq))
      query_str <- gsub("-", "", query_str)
      
      print(paste("Cleaned length:", nchar(query_str)))
      
      query_dna <- DNAString(query_str)
      ref_dna <- DNAString(vr2332_3188_ref)
      
      # Perform global-local alignment
      alignment <- pwalign::pairwiseAlignment(
        pattern = query_dna,
        subject = ref_dna,
        type = "global-local"
      )
      
      print("Alignment completed")
      
      # Get alignment details
      subject_start <- pwalign::start(pwalign::subject(alignment))
      subject_end <- pwalign::end(pwalign::subject(alignment))
      
      print(paste("Subject start:", subject_start, "Subject end:", subject_end))
      
      aligned_pattern <- as.character(pwalign::alignedPattern(alignment))
      aligned_subject <- as.character(pwalign::alignedSubject(alignment))
      
      print(paste("Aligned pattern length:", nchar(aligned_pattern)))
      
      # Build result sequence of exactly 3188 nt
      result_chars <- rep("-", 3188)
      
      # Map aligned query to reference positions
      ref_pos <- subject_start
      pattern_chars <- strsplit(aligned_pattern, "")[[1]]
      subject_chars <- strsplit(aligned_subject, "")[[1]]
      
      for (i in seq_along(pattern_chars)) {
        if (subject_chars[i] != "-") {
          if (ref_pos >= 1 && ref_pos <= 3188) {
            result_chars[ref_pos] <- pattern_chars[i]
          }
          ref_pos <- ref_pos + 1
        }
      }
      
      result <- paste(result_chars, collapse = "")
      print(paste("Result length:", nchar(result)))
      
      # Calculate nucleotide coverage
      non_gap_count <- sum(result_chars != "-")
      coverage <- non_gap_count / 3188
      print(paste("Nucleotide coverage:", round(coverage * 100, 1), "% (", non_gap_count, "/ 3188 non-gap nucleotides)"))
      
      return(list(
        aligned_seq = result,
        coverage = coverage,
        non_gap_count = non_gap_count
      ))
    }, error = function(e) {
      print(paste("ERROR in align_to_vr2332_3188:", e$message))
      # Fallback: pad or trim
      seq_str <- toupper(as.character(query_seq))
      seq_str <- gsub("-", "", seq_str)
      if (nchar(seq_str) > 3188) {
        result <- substr(seq_str, 1, 3188)
      } else if (nchar(seq_str) < 3188) {
        result <- paste0(seq_str, paste(rep("-", 3188 - nchar(seq_str)), collapse = ""))
      } else {
        result <- seq_str
      }
      non_gap_count <- sum(strsplit(result, "")[[1]] != "-")
      return(list(
        aligned_seq = result,
        coverage = non_gap_count / 3188,
        non_gap_count = non_gap_count
      ))
    })
  }
  
  # Translate gene sequence with validity tracking
  translate_gene_with_tracking <- function(gene_nt_seq, gene_name) {
    gene_nt_seq <- toupper(as.character(gene_nt_seq))
    gene_len <- nchar(gene_nt_seq)
    
    # Calculate expected AA length (excluding stop codon)
    expected_aa_len <- floor(gene_len / 3)
    if (gene_len %% 3 != 0) {
      print(paste("WARNING:", gene_name, "length", gene_len, "not divisible by 3"))
    }
    
    aa_seq <- character(expected_aa_len)
    valid_positions <- logical(expected_aa_len)
    
    for (i in 1:expected_aa_len) {
      start_pos <- (i - 1) * 3 + 1
      codon <- substr(gene_nt_seq, start_pos, start_pos + 2)
      aa <- safe_translate_codon(codon)
      
      if (!is.na(aa)) {
        aa_seq[i] <- aa
        valid_positions[i] <- TRUE
      } else {
        aa_seq[i] <- "X"  # Placeholder for invalid
        valid_positions[i] <- FALSE
      }
    }
    
    # Remove terminal stop codon if present (last position)
    if (expected_aa_len > 0 && aa_seq[expected_aa_len] == "X") {
      # Check if it was actually a stop codon
      last_codon <- substr(gene_nt_seq, (expected_aa_len - 1) * 3 + 1, expected_aa_len * 3)
      if (!grepl("-", last_codon) && !grepl("[^ATGC]", last_codon)) {
        tryCatch({
          last_aa <- as.character(Biostrings::translate(DNAString(last_codon)))
          if (last_aa == "*") {
            # It's a proper stop codon, remove it
            aa_seq <- aa_seq[-expected_aa_len]
            valid_positions <- valid_positions[-expected_aa_len]
            expected_aa_len <- expected_aa_len - 1
          }
        }, error = function(e) {})
      }
    }
    
    coverage <- sum(valid_positions) / length(valid_positions)
    invalid_count <- sum(!valid_positions)
    
    return(list(
      aa_seq = paste(aa_seq, collapse = ""),
      valid_positions = valid_positions,
      coverage = coverage,
      invalid_count = invalid_count
    ))
  }
  
  # ===== END MULTI-GENE HELPER FUNCTIONS =====
  
  # for single-gene - flexible version
  read_and_translate <- function(file, text, type = c("dna", "aa"), seq_type = "viral", other_seqs = NULL) {
    type <- match.arg(type)
    
    if (type == "aa") {
      stop("Amino acid sequences are not supported. Please provide nucleotide sequences.")
    }
    
    raw_seqs <- NULL
    
    # === STEP A: Read raw sequences and convert U to T ===
    if (!is.null(file)) {
      # Read raw file and check for U nucleotides
      raw_lines <- readLines(file$datapath)
      
      if (any(grepl("[Uu]", raw_lines))) {
        u_total <- sum(nchar(gsub("[^Uu]", "", raw_lines)))
        print(paste("=== DETECTED", u_total, "U nucleotides (RNA sequences) - converting to T (DNA) ==="))
        raw_lines <- gsub("[Uu]", "T", raw_lines)
        print("=== All U nucleotides converted to T ===")
        
        # Write corrected sequence to temp file
        temp_file <- tempfile(fileext = ".fasta")
        writeLines(raw_lines, temp_file)
        
        raw_seqs <- tryCatch({
          readDNAStringSet(temp_file)
        }, error = function(e) {
          stop(paste("Failed to read FASTA file:", e$message))
        }, finally = {
          unlink(temp_file)
        })
      } else {
        raw_seqs <- tryCatch({
          readDNAStringSet(file$datapath)
        }, error = function(e) {
          stop(paste("Failed to read FASTA file:", e$message))
        })
      }
      
    } else if (nchar(trimws(text)) > 0) {
      text <- trimws(text)
      
      # Check for U nucleotides in pasted text
      if (grepl("[Uu]", text)) {
        u_total <- nchar(gsub("[^Uu]", "", text))
        print(paste("=== DETECTED", u_total, "U nucleotides (RNA sequences) - converting to T (DNA) ==="))
        text <- gsub("[Uu]", "T", text)
        print("=== All U nucleotides converted to T ===")
      }
      
      lines <- strsplit(text, "\n")[[1]]
      lines <- lines[nchar(trimws(lines)) > 0]
      has_headers <- any(grepl("^>", lines))
      
      if (!has_headers) {
        fasta_lines <- character()
        for (i in seq_along(lines)) {
          current_seq <- trimws(lines[i])
          suffix_letter <- LETTERS[((i - 1) %% 26) + 1]
          if (i > 26) suffix_letter <- paste0(suffix_letter, ceiling(i / 26))
          
          if (seq_type == "viral") {
            seq_name <- paste0("outbreak_virus_", suffix_letter)
          } else {
            seq_name <- paste0("vaccine_LVI_virus_", suffix_letter)
          }
          fasta_lines <- c(fasta_lines, paste0(">", seq_name), current_seq)
        }
        text <- paste(fasta_lines, collapse = "\n")
      }
      
      temp_file <- tempfile(fileext = ".fasta")
      writeLines(text, temp_file)
      raw_seqs <- tryCatch({
        readDNAStringSet(temp_file)
      }, error = function(e) {
        stop(paste("Failed to parse FASTA text:", e$message))
      }, finally = {
        unlink(temp_file)
      })
    }
    
    # === STEP B: Process each sequence ===
    aligned_nt <- list()
    aa_seqs_list <- list()
    valid_positions_list <- list()
    rejected_seqs <- character()
    
    for (seq_name in names(raw_seqs)) {
      seq_str <- as.character(raw_seqs[[seq_name]])
      seq_str <- gsub("-", "", seq_str)  # Remove gaps for length check
      seq_str <- toupper(seq_str)
      seq_len <- nchar(seq_str)
      
      # Align if not exactly 603 nt
      if (seq_len != 603) {
        aligned_seq <- align_to_vr2332(seq_str)
      } else {
        aligned_seq <- seq_str
      }
      
      # Translate with tracking
      trans_result <- translate_with_tracking(aligned_seq)
      
      # Check coverage threshold (70%)
      if (trans_result$coverage < 0.70) {
        print(paste("REJECTED:", seq_name, "- coverage too low"))
        rejected_seqs <- c(rejected_seqs, 
                           paste0("Sequence '", seq_name, "' is invalid due to low coverage (", 
                                  round(trans_result$coverage * 100, 1), "%)"))
        next
      }
      
      print(paste("ACCEPTED:", seq_name))
      # Store valid sequence
      aligned_nt[[seq_name]] <- aligned_seq
      aa_seqs_list[[seq_name]] <- trans_result$aa_seq
      valid_positions_list[[seq_name]] <- trans_result$valid_positions
    }
    
    # === STEP C: Return results ===
    if (length(aa_seqs_list) == 0) {
      print(paste("=== read_and_translate finished ==="))
      print(paste("Returning 0 aa_seqs, 0 nt_seqs"))
      print(paste("Rejected:", length(rejected_seqs), "sequences"))
      
      return(list(
        aa_seqs = AAStringSet(),
        nt_seqs = DNAStringSet(),
        valid_positions = list(),
        rejected_seqs = rejected_seqs
      ))
    }
    
    aa_seqs <- AAStringSet(unlist(aa_seqs_list))
    names(aa_seqs) <- names(aa_seqs_list)
    
    nt_seqs <- DNAStringSet(unlist(aligned_nt))
    names(nt_seqs) <- names(aligned_nt)
    
    return(list(
      aa_seqs = aa_seqs,
      nt_seqs = nt_seqs,
      valid_positions = valid_positions_list,
      rejected_seqs = rejected_seqs
    ))
  }
  
  validate_aa_sequences <- function(aa_seqs) {
    bad_info <- list()
    for (nm in names(aa_seqs)) {
      seq <- as.character(aa_seqs[[nm]])
      seq_issues <- character()
      if (nchar(seq) != 200) {
        if (nchar(seq) < 200) {
          seq_issues <- c(seq_issues, paste0("sequence is too short (", nchar(seq), " amino acids, expected 200)"))
        } else {
          seq_issues <- c(seq_issues, paste0("sequence is too long (", nchar(seq), " amino acids, expected 200)"))
        }
      }
      stop_positions <- gregexpr("\\*", seq)[[1]]
      if (length(stop_positions) > 0 && stop_positions[1] != -1) {
        premature_stops <- stop_positions[stop_positions < 200]
        if (length(premature_stops) > 0) {
          seq_issues <- c(seq_issues, paste0("premature stop codon at position(s) ", paste(premature_stops, collapse = ", ")))
        }
      }
      x_positions <- gregexpr("X", seq)[[1]]
      if (length(x_positions) > 0 && x_positions[1] != -1) {
        seq_issues <- c(seq_issues, paste0("unknown amino acid (X) at position(s) ", paste(x_positions, collapse = ", ")))
      }
      aa_split <- strsplit(seq, "")[[1]]
      illegal_aa <- setdiff(aa_split, legal_aa)
      if (length(illegal_aa) > 0) {
        illegal_positions <- which(aa_split %in% illegal_aa)
        seq_issues <- c(seq_issues, paste0("illegal amino acid code(s) '", paste(unique(illegal_aa), collapse = "', '"), "' at position(s) ", paste(illegal_positions, collapse = ", ")))
      }
      if (length(seq_issues) > 0) {
        bad_info[[nm]] <- seq_issues
      }
    }
    return(bad_info)
  }
  
  robust_load_model <- function(filepath) {
    objs_before <- ls()
    load(filepath)
    objs_after <- ls()
    new_objs <- setdiff(objs_after, objs_before)
    if ("model" %in% new_objs) {
      mdl <- get("model")
      if ("selected_features" %in% new_objs) {
        req_feats <- get("selected_features")
      } else if (!is.null(mdl$finalModel$xNames)) {
        req_feats <- mdl$finalModel$xNames
      } else if (!is.null(mdl$trainingData)) {
        req_feats <- names(mdl$trainingData)[-ncol(mdl$trainingData)]
      } else {
        stop("Could not determine feature set for model.")
      }
      rm(list=new_objs)
      return(list(model = mdl, features = req_feats))
    } else if (length(new_objs) == 1) {
      mdl <- get(new_objs[1])
      req_feats <- if (!is.null(mdl$finalModel$xNames)) mdl$finalModel$xNames else names(mdl$trainingData)[-ncol(mdl$trainingData)]
      rm(list=new_objs)
      return(list(model = mdl, features = req_feats))
    } else {
      stop(paste0("RData file must contain at least a model object named 'model': ", filepath))
    }
  }
  
  extract_features <- function(virus_id, serum_id, aa_ali_tidy, aa_feature_map, all_glyco_sites, nt_seqs_viral, nt_seqs_serum, variant_viral, variant_serum) {
    virus_seq <- aa_ali_tidy[virus_id, ]
    serum_seq <- aa_ali_tidy[serum_id, ]
    features <- list()
    
    # Basic AA distance
    features$aa_dist <- hamming_distance(unlist(virus_seq), unlist(serum_seq))
    
    # Ectodomain AA distance
    ecto_cols <- c()
    for (range in orf5_ectodomain_ranges) {
      ecto_cols <- c(ecto_cols, sprintf("p%03d", range[1]:range[2]))
    }
    ecto_cols <- ecto_cols[ecto_cols %in% colnames(aa_ali_tidy)]
    
    if (length(ecto_cols) > 0) {
      virus_ecto <- unlist(virus_seq[ecto_cols])
      serum_ecto <- unlist(serum_seq[ecto_cols])
      features$ecto_aa_dist <- hamming_distance(virus_ecto, serum_ecto)
    } else {
      features$ecto_aa_dist <- NA_real_
    }
    
    # Nucleotide distances
    if (!is.null(nt_seqs_viral) && !is.null(nt_seqs_serum) && 
        virus_id %in% names(nt_seqs_viral) && serum_id %in% names(nt_seqs_serum)) {
      
      virus_nt <- nt_seqs_viral[[virus_id]]
      serum_nt <- nt_seqs_serum[[serum_id]]
      
      # Full nucleotide distance
      features$nt_dist <- calculate_nt_distance(virus_nt, serum_nt)
      
      # Ectodomain nucleotide distance
      ecto_nt_positions <- c()
      for (range in orf5_ectodomain_ranges) {
        start_nt <- (range[1] - 1) * 3 + 1
        end_nt <- range[2] * 3
        ecto_nt_positions <- c(ecto_nt_positions, start_nt:end_nt)
      }
      
      if (length(ecto_nt_positions) > 0 && 
          nchar(as.character(virus_nt)) >= max(ecto_nt_positions) && 
          nchar(as.character(serum_nt)) >= max(ecto_nt_positions)) {
        virus_ecto_nt <- substr(as.character(virus_nt), min(ecto_nt_positions), max(ecto_nt_positions))
        serum_ecto_nt <- substr(as.character(serum_nt), min(ecto_nt_positions), max(ecto_nt_positions))
        features$ecto_nt_dist <- calculate_nt_distance(virus_ecto_nt, serum_ecto_nt)
      } else {
        features$ecto_nt_dist <- NA_real_
      }
    } else {
      features$nt_dist <- NA_real_
      features$ecto_nt_dist <- NA_real_
    }
    
    # Variant relationship features
    if (!is.null(variant_viral) && !is.null(variant_serum) && 
        virus_id %in% names(variant_viral) && serum_id %in% names(variant_serum)) {
      
      virus_var <- variant_viral[[virus_id]]
      serum_var <- variant_serum[[serum_id]]
      
      # Extract main lineage (e.g. "1C" from "1C.2")
      serum_main <- str_extract(serum_var, "^[0-9]+[A-Z]")
      viral_main <- str_extract(virus_var, "^[0-9]+[A-Z]")
      
      # Extract sublineage after dot (if any)
      serum_sub <- str_extract(serum_var, "(?<=\\.)[^-]+")
      viral_sub <- str_extract(virus_var, "(?<=\\.)[^-]+")
      
      # Extract lineage number only (e.g. "1" from "1C")
      serum_num <- str_extract(serum_var, "^[0-9]+")
      viral_num <- str_extract(virus_var, "^[0-9]+")
      
      # Initialize all variant features to 0
      features$diff_L <- 0L
      features$same_L <- 0L
      features$same_SL <- 0L
      features$samevar <- 0L
      
      if (!is.na(serum_main) && !is.na(viral_main) && !is.na(serum_num) && !is.na(viral_num)) {
        if (serum_var == virus_var) {
          # Exact same variant
          features$samevar <- 1L
        } else if (serum_main == viral_main) {
          # Same main lineage, different sublineage or same with unclassified
          features$same_SL <- 1L
        } else if (serum_num == viral_num && serum_main != viral_main) {
          # Same number but different letter in main lineage
          features$same_L <- 1L
        } else if (serum_num != viral_num) {
          # Different lineage number
          features$diff_L <- 1L
        } else {
          # Default to different lineage
          features$diff_L <- 1L
        }
      } else {
        # If variant parsing failed, default to different lineage
        features$diff_L <- 1L
      }
    } else {
      # Default values if variant information is missing
      features$diff_L <- 1L
      features$same_L <- 0L
      features$same_SL <- 0L
      features$samevar <- 0L
    }
    
    # Glycosylation sites
    virus_glyco <- find_glyco_sites(unlist(virus_seq))
    serum_glyco <- find_glyco_sites(unlist(serum_seq))
    for (site in all_glyco_sites) {
      v_gly <- as.integer(site %in% virus_glyco)
      s_gly <- as.integer(site %in% serum_glyco)
      features[[paste0("nogly_", sprintf("%03d", site))]] <- as.integer(v_gly == 0 && s_gly == 0)
      features[[paste0("gly_s_", sprintf("%03d", site))]] <- as.integer(v_gly == 0 && s_gly == 1)
      features[[paste0("gly_v_", sprintf("%03d", site))]] <- as.integer(v_gly == 1 && s_gly == 0)
      features[[paste0("gly_both_", sprintf("%03d", site))]] <- as.integer(v_gly == 1 && s_gly == 1)
    }
    
    # Position-specific features
    for (i in 1:200) {
      pos_str <- sprintf("%03d", i)
      colname <- paste0("p", pos_str)
      vaa <- virus_seq[[colname]]
      saa <- serum_seq[[colname]]
      features[[paste0("p", pos_str, "_same")]] <- as.integer(!is.na(vaa) && !is.na(saa) && vaa == saa)
      
      # AAindex features
      for (shortname in names(aa_feature_map)) {
        fmap <- aa_feature_map[[shortname]]
        val <- 0
        if (!is.na(vaa) && !is.na(saa) && vaa %in% names(fmap) && saa %in% names(fmap)) {
          val <- fmap[[saa]] - fmap[[vaa]]
        }
        features[[paste0("p", pos_str, "_", shortname)]] <- val
      }
      
      # Amino acid class transitions
      from_class <- get_aa_class(saa)
      to_class <- get_aa_class(vaa)
      trans_key <- paste0("p", pos_str, "_s_", from_class, "_v_", to_class)
      features[[trans_key]] <- as.integer((!is.na(vaa) && !is.na(saa)) && vaa != saa)
    }
    
    return(features)
  }
  
  # ===== MAIN PREDICTION LOGIC =====
  observeEvent(input$runpred, {
    # Reset states
    values$showResults <- FALSE
    values$showProcessing <- TRUE  
    values$showError <- FALSE
    values$errorMessage <- ""
    values$validationMessage <- ""
    values$predictionTable <- NULL
    
    output$summary_table <- renderDataTable({ NULL })
    
    delay(200, {
      tryCatch({
        # Check file sizes (5MB limit = 5 * 1024^2 bytes)
        max_size <- 5 * 1024^2
        
        if (!is.null(input$file_viral)) {
          viral_size <- file.info(input$file_viral$datapath)$size
          if (viral_size > max_size) {
            stop(paste0("Outbreak virus file is too large (", 
                       round(viral_size / 1024^2, 2), " MB). ",
                       "Maximum file size is 5 MB. Please check your file."))
          }
        }
        
        if (!is.null(input$file_serum) && input$inputmode == "both") {
          serum_size <- file.info(input$file_serum$datapath)$size
          if (serum_size > max_size) {
            stop(paste0("Vaccine/LVI virus file is too large (", 
                       round(serum_size / 1024^2, 2), " MB). ",
                       "Maximum file size is 5 MB. Please check your file."))
          }
        }
        
        # Check pasted text size (approximate)
        if (!is.null(input$fasta_viral) && nchar(input$fasta_viral) > 0) {
          text_size <- nchar(input$fasta_viral)
          if (text_size > max_size) {
            stop(paste0("Pasted outbreak virus text is too large (approximately ", 
                       round(text_size / 1024^2, 2), " MB). ",
                       "Maximum size is 5 MB. Please reduce the amount of data."))
          }
        }
        
        if (!is.null(input$fasta_serum) && nchar(input$fasta_serum) > 0 && input$inputmode == "both") {
          text_size <- nchar(input$fasta_serum)
          if (text_size > max_size) {
            stop(paste0("Pasted vaccine/LVI virus text is too large (approximately ", 
                       round(text_size / 1024^2, 2), " MB). ",
                       "Maximum size is 5 MB. Please reduce the amount of data."))
          }
        }
        
        if (input$model_type == "single") {
          # ===== SINGLE-GENE PREDICTION LOGIC =====
          
          print("=== SINGLE-GENE PREDICTION START ===")
          
          # Handle viral sequences
          viral <- NULL
          viral_error <- NULL
          tryCatch({
            viral <- read_and_translate(input$file_viral, input$fasta_viral, type = "dna", seq_type = "viral")
            print(paste("Viral sequences loaded:", length(viral$aa_seqs)))
          }, error = function(e) {
            viral_error <<- e$message
            print(paste("VIRAL ERROR:", e$message))
          })
          
          # Handle serum sequences
          serum <- NULL
          serum_error <- NULL
          tryCatch({
            if (input$inputmode == "viral_only") {
              print("Using built-in vaccine sequences")
              # Use built-in vaccine sequences
              aa_seqs <- AAStringSet(unlist(serum_strains))
              nt_seqs <- DNAStringSet(unlist(serum_nt_strains))
              names(nt_seqs) <- names(aa_seqs)
              # Built-in sequences are all valid
              valid_positions <- lapply(names(aa_seqs), function(x) rep(TRUE, 200))
              names(valid_positions) <- names(aa_seqs)
              serum <- list(aa_seqs = aa_seqs, nt_seqs = nt_seqs, valid_positions = valid_positions, rejected_seqs = character())
              print(paste("Built-in serum sequences:", length(serum$aa_seqs)))
            } else {
              print("Loading user serum sequences")
              serum <- read_and_translate(input$file_serum, input$fasta_serum, type = "dna", seq_type = "serum")
              print(paste("User serum sequences loaded:", length(serum$aa_seqs)))
            }
          }, error = function(e) {
            serum_error <<- e$message
            print(paste("SERUM ERROR:", e$message))
          })
          
          print(paste("viral_error:", ifelse(is.null(viral_error), "NULL", viral_error)))
          print(paste("serum_error:", ifelse(is.null(serum_error), "NULL", serum_error)))
          
          # Check for errors
          if (!is.null(viral_error) || !is.null(serum_error)) {
            print("ERROR DETECTED - returning early")
            values$showProcessing <- FALSE
            values$showError <- TRUE
            error_msg <- "Error processing sequences:\n"
            if (!is.null(viral_error)) error_msg <- paste0(error_msg, "Viral: ", viral_error, "\n")
            if (!is.null(serum_error)) error_msg <- paste0(error_msg, "Serum: ", serum_error, "\n")
            values$errorMessage <- error_msg
            return()
          }
          
          print("No errors detected, continuing...")
          
          # Collect rejection messages
          print("Collecting rejection messages...")
          rejection_messages <- c()
          if (length(viral$rejected_seqs) > 0) {
            rejection_messages <- c(rejection_messages, "OUTBREAK VIRUS:", viral$rejected_seqs)
          }
          if (length(serum$rejected_seqs) > 0) {
            rejection_messages <- c(rejection_messages, "VACCINE/LVI VIRUS:", serum$rejected_seqs)
          }
          print(paste("Rejection messages:", length(rejection_messages)))
          
          # Check if any valid sequences remain
          print(paste("Checking valid sequences - viral:", length(viral$aa_seqs), "serum:", length(serum$aa_seqs)))
          
          if (length(viral$aa_seqs) == 0) {
            print("No valid viral sequences!")
            values$showProcessing <- FALSE
            values$showError <- TRUE
            values$errorMessage <- paste(c("No valid outbreak virus sequences remaining after filtering.", rejection_messages), collapse = "\n")
            return()
          }
          
          if (length(serum$aa_seqs) == 0) {
            print("No valid serum sequences!")
            values$showProcessing <- FALSE
            values$showError <- TRUE
            values$errorMessage <- paste(c("No valid vaccine/LVI virus sequences remaining after filtering.", rejection_messages), collapse = "\n")
            return()
          }
          
          print("Building validation message...")
          # Build validation message
          validation_msg <- ""
          if (length(rejection_messages) > 0) {
            validation_msg <- paste0("Some sequences were rejected:\n", paste(rejection_messages, collapse = "\n"), "\n\nProceeding with valid sequences...\n")
          }
          validation_msg <- paste0(validation_msg, "Valid outbreak sequences: ", length(viral$aa_seqs), 
                                   "\nValid vaccine/LVI sequences: ", length(serum$aa_seqs), "\n")
          
          values$validationMessage <- validation_msg
          print("Validation message set")
          
          print("=== Starting variant prediction ===")
          print(paste("viral$nt_seqs names:", paste(names(viral$nt_seqs), collapse=", ")))
          
          # Predict variants with timeout
          viral_variants <- tryCatch({
            R.utils::withTimeout(predict_variants(viral$nt_seqs, use_github = TRUE), timeout = 30)
          }, TimeoutException = function(ex) {
            setNames(rep("unclassified", length(viral$nt_seqs)), names(viral$nt_seqs))
          })
          serum_variants_pred <- predict_variants(serum$nt_seqs, use_github = (input$inputmode == "both"))
          
          # Create position-wise dataframe
          viral_seqs_renamed <- viral$aa_seqs
          serum_seqs_renamed <- serum$aa_seqs
          names(viral_seqs_renamed) <- paste0("viral_", names(viral_seqs_renamed))
          names(serum_seqs_renamed) <- paste0("serum_", names(serum_seqs_renamed))
          
          allseqs <- c(viral_seqs_renamed, serum_seqs_renamed)
          aa_list <- lapply(allseqs, function(x) strsplit(as.character(x), "")[[1]][1:200])
          aa_ali_tidy <- do.call(rbind, aa_list)
          aa_ali_tidy <- as.data.frame(aa_ali_tidy, stringsAsFactors = FALSE)
          colnames(aa_ali_tidy) <- sprintf("p%03d", 1:200)
          rownames(aa_ali_tidy) <- names(allseqs)
          
          # Apply same naming to nucleotide sequences
          viral_nt_renamed <- viral$nt_seqs
          serum_nt_renamed <- serum$nt_seqs
          names(viral_nt_renamed) <- paste0("viral_", names(viral_nt_renamed))
          names(serum_nt_renamed) <- paste0("serum_", names(serum_nt_renamed))
          all_nt_seqs <- c(viral_nt_renamed, serum_nt_renamed)
          
          # Find glycosylation sites
          all_glyco_sites <- unique(unlist(lapply(1:nrow(aa_ali_tidy), function(i) { 
            find_glyco_sites(unlist(aa_ali_tidy[i,])) 
          }))) %>% sort()
          
          viral_names <- paste0("viral_", names(viral$aa_seqs))
          serum_names <- paste0("serum_", names(serum$aa_seqs))
          
          # Extract features for all pairs
          feature_rows <- list()
          meta_rows <- list()
          variant_info_rows <- list()
          
          for (vi in viral_names) {
            for (si in serum_names) {
              vi_display <- gsub("^viral_", "", vi)
              si_display <- gsub("^serum_", "", si)
              vi_original <- gsub("^viral_", "", vi)
              si_original <- gsub("^serum_", "", si)
              
              virus_var <- if(vi_original %in% names(viral_variants)) viral_variants[[vi_original]] else "unclassified"
              serum_var <- if(si_original %in% names(serum_variants_pred)) serum_variants_pred[[si_original]] else "unclassified"
              
              features <- extract_features(vi, si, aa_ali_tidy, aa_feature_map, all_glyco_sites, 
                                           all_nt_seqs, all_nt_seqs, viral_variants, serum_variants_pred)
              feature_rows[[paste(vi, si, sep="|")]] <- features
              meta_rows[[paste(vi, si, sep="|")]] <- list(vaccine_LVI_virus=si_display, outbreak_virus=vi_display)
              variant_info_rows[[paste(vi, si, sep="|")]] <- list(
                vaccine_LVI_virus=si_display, 
                outbreak_virus=vi_display,
                vaccine_LVI_variant=serum_var,
                outbreak_variant=virus_var
              )
            }
          }
          
          variant_info_df <- bind_rows(variant_info_rows)
          feature_df <- bind_cols(bind_rows(meta_rows), bind_rows(feature_rows))
          
          # Track sequence-level imputation for reporting
          viral_imputation <- list()
          serum_imputation <- list()
          
          # Count invalid positions and affected features for viral sequences
          for (seq_name in names(viral$valid_positions)) {
            valid_pos <- viral$valid_positions[[seq_name]]
            invalid_count <- sum(!valid_pos)
            if (invalid_count > 0) {
              # Count how many features are affected (rough estimate based on position-specific features)
              # Each invalid position affects: _same, 6 AAindex features, and multiple transition features
              # Conservative estimate: ~10 features per invalid position
              affected_features <- invalid_count * 10
              
              viral_imputation[[seq_name]] <- list(
                invalid_count = invalid_count,
                coverage = sum(valid_pos) / length(valid_pos),
                affected_features = affected_features
              )
            }
          }
          
          # Count invalid positions for serum sequences (skip built-in vaccines if using them)
          if (input$inputmode == "both") {
            for (seq_name in names(serum$valid_positions)) {
              valid_pos <- serum$valid_positions[[seq_name]]
              invalid_count <- sum(!valid_pos)
              if (invalid_count > 0) {
                affected_features <- invalid_count * 10
                
                serum_imputation[[seq_name]] <- list(
                  invalid_count = invalid_count,
                  coverage = sum(valid_pos) / length(valid_pos),
                  affected_features = affected_features
                )
              }
            }
          }
          
          print("=== Sequence-level Imputation Summary ===")
          print(paste("Viral sequences with imputation:", length(viral_imputation)))
          print(paste("Serum sequences with imputation:", length(serum_imputation)))
          
          # Load LightGBM model for single-gene
          lightgbm_model <- load_lightgbm_model(lightgbm_sg_model_path)
          
          # Load features with median values for imputation (single-gene feature list)
          lgb_features_df <- read.csv(lightgbm_sg_features_path, stringsAsFactors = FALSE)
          lgb_features <- lgb_features_df$feature
          median_values <- setNames(lgb_features_df$median, lgb_features_df$feature)
          
          # Impute missing feature columns using median values
          lgb_missing_feats <- setdiff(lgb_features, colnames(feature_df))
          if (length(lgb_missing_feats) > 0) {
            print(paste("=== LightGBM (single-gene): Imputing", length(lgb_missing_feats), "missing features with median values ==="))
            for (f in lgb_missing_feats) {
              if (f %in% names(median_values)) {
                feature_df[[f]] <- median_values[[f]]
              } else {
                feature_df[[f]] <- 0
              }
            }
            print(paste("Missing features imputed:", paste(lgb_missing_feats, collapse = ", ")))
          }
          
          lgb_feature_df <- feature_df[, lgb_features, drop = FALSE]
          
          # Replace NA with median values for LightGBM and print examples
          na_imputation_count <- 0
          for (col in colnames(lgb_feature_df)) {
            na_idx <- which(is.na(lgb_feature_df[[col]]))
            if (length(na_idx) > 0) {
              if (col %in% names(median_values)) {
                lgb_feature_df[[col]][na_idx] <- median_values[[col]]
                for (row_idx in na_idx[1:min(3, length(na_idx))]) {
                  pair_name <- paste0(feature_df$outbreak_virus[row_idx], " vs ", feature_df$vaccine_LVI_virus[row_idx])
                  print(paste("LightGBM - Imputing NA for feature '", col, "' in pair '", pair_name, "' with median:", round(median_values[[col]], 4)))
                }
                if (length(na_idx) > 3) {
                  print(paste("  ... and", length(na_idx) - 3, "more NA values for", col))
                }
              } else {
                lgb_feature_df[[col]][na_idx] <- 0
                for (row_idx in na_idx[1:min(3, length(na_idx))]) {
                  pair_name <- paste0(feature_df$outbreak_virus[row_idx], " vs ", feature_df$vaccine_LVI_virus[row_idx])
                  print(paste("LightGBM - Imputing NA for feature '", col, "' in pair '", pair_name, "' with 0 (no median available)"))
                }
              }
              na_imputation_count <- na_imputation_count + length(na_idx)
            }
          }
          
          print("=== Imputation Summary ===")
          print(paste("LightGBM - Total features imputed (missing columns):", length(lgb_missing_feats)))
          print(paste("LightGBM - Total NA values imputed:", na_imputation_count))
          
          # Predictions (LightGBM only)
          lgb_matrix <- as.matrix(lgb_feature_df)
          lgb_raw_preds <- predict(lightgbm_model, lgb_matrix)
          lgb_probs_high <- lgb_raw_preds
          lgb_probs_low <- 1 - lgb_raw_preds
          lgb_preds <- ifelse(lgb_raw_preds > 0.5, "high", "low")
          
          # Build prediction table matching multi-gene column names
          pred_table <- feature_df[,c("vaccine_LVI_virus","outbreak_virus")]
          pred_table[["Neutralizing Titer Prediction"]] <- lgb_preds
          pred_table[["Prediction Probability"]] <- ifelse(lgb_preds == "high",
                                                           round(lgb_probs_high, 3),
                                                           round(lgb_probs_low, 3))
          pred_table <- merge(pred_table, variant_info_df, by = c("vaccine_LVI_virus", "outbreak_virus"), all.x = TRUE)
          values$predictionTable <- pred_table
          
          # Success - build detailed validation message
          values$showProcessing <- FALSE
          values$showError <- FALSE
          values$showResults <- TRUE
          
          # Build imputation summary message (LightGBM-only)
          if (length(viral_imputation) > 0 || length(serum_imputation) > 0) {
            imputation_msg <- "\n=== Imputation Summary ===\n"
            imputation_msg <- paste0(imputation_msg, 
                                     format_imputation_summary(viral_imputation, "Outbreak Virus"))
            imputation_msg <- paste0(imputation_msg, 
                                     format_imputation_summary(serum_imputation, "Vaccine/LVI Virus"))
            
            total_imputed <- length(viral_imputation) + length(serum_imputation)
            imputation_msg <- paste0(imputation_msg, 
                                     "\nTotal: ", total_imputed, " sequence(s) had features imputed due to invalid/ambiguous nucleotides.\n",
                                     "Note: Invalid positions were replaced with median values from internal cross-neutralization data.\n")
            
            values$validationMessage <- paste0("Prediction completed successfully.\n", imputation_msg)
          } else {
            values$validationMessage <- "All sequences passed validation with no imputation needed. Prediction completed successfully."
          }
          
          output$summary_table <- DT::renderDataTable({ 
            values$predictionTable
          }, options = list(
            paging = FALSE,
            ordering = TRUE,
            scrollY = "400px",
            scrollX = TRUE,
            columnDefs = list(
              list(className = 'dt-center', targets = "_all"),
              list(render = JS("function(data, type, row) {
                return type === 'display' && data != null ? Number(data).toFixed(3) : data;
              }"), targets = 3)
            )
          ), rownames = FALSE, class = 'cell-border stripe')
          
        } else {
          # ===== MULTI-GENE PREDICTION LOGIC =====
          
          print("=== MULTI-GENE PREDICTION START ===")
          
          # Process viral sequences
          viral <- NULL
          viral_error <- NULL
          tryCatch({
            viral <- read_and_process_3188(input$file_viral, input$fasta_viral, seq_type = "viral")
            print(paste("Viral sequences loaded:", length(viral$genes_aa)))
          }, error = function(e) {
            viral_error <<- e$message
            print(paste("VIRAL ERROR:", e$message))
          })
          
          # Process serum sequences
          serum <- NULL
          serum_error <- NULL
          tryCatch({
            if (input$inputmode == "viral_only") {
              print("Using built-in vaccine sequences")
              all_genes_nt <- list()
              all_genes_aa <- list()
              all_valid_positions <- list()
              
              for (vaccine_name in names(vaccine_full_nt_seqs)) {
                full_seq <- vaccine_full_nt_seqs[[vaccine_name]]
                genes_nt <- extract_genes(full_seq)
                genes_aa <- list()
                gene_valid_positions <- list()
                
                for (gene_name in names(genes_nt)) {
                  gene_nt_seq <- DNAString(genes_nt[[gene_name]])
                  gene_aa_seq <- translate(gene_nt_seq)
                  aa_char <- as.character(gene_aa_seq)
                  # Remove stop codon
                  if (nchar(aa_char) > 0 && substr(aa_char, nchar(aa_char), nchar(aa_char)) == "*") {
                    aa_char <- substr(aa_char, 1, nchar(aa_char) - 1)
                  }
                  genes_aa[[gene_name]] <- aa_char
                  # Built-in sequences are all valid
                  gene_valid_positions[[gene_name]] <- rep(TRUE, nchar(aa_char))
                }
                
                all_genes_nt[[vaccine_name]] <- genes_nt
                all_genes_aa[[vaccine_name]] <- genes_aa
                all_valid_positions[[vaccine_name]] <- gene_valid_positions
              }
              serum <- list(
                genes_nt = all_genes_nt, 
                genes_aa = all_genes_aa, 
                valid_positions = all_valid_positions,
                warning_msg = "",
                rejected_seqs = character()
              )
              print(paste("Built-in serum sequences:", length(serum$genes_aa)))
            } else {
              print("Loading user serum sequences")
              serum <- read_and_process_3188(input$file_serum, input$fasta_serum, seq_type = "serum")
              print(paste("User serum sequences loaded:", length(serum$genes_aa)))
            }
          }, error = function(e) {
            serum_error <<- e$message
            print(paste("SERUM ERROR:", e$message))
          })
          
          print(paste("viral_error:", ifelse(is.null(viral_error), "NULL", viral_error)))
          print(paste("serum_error:", ifelse(is.null(serum_error), "NULL", serum_error)))
          
          # Check for errors
          if (!is.null(viral_error) || !is.null(serum_error)) {
            print("ERROR DETECTED - returning early")
            values$showProcessing <- FALSE
            values$showError <- TRUE
            error_msg <- "Error processing sequences:\n"
            if (!is.null(viral_error)) error_msg <- paste0(error_msg, "Viral: ", viral_error, "\n")
            if (!is.null(serum_error)) error_msg <- paste0(error_msg, "Serum: ", serum_error, "\n")
            values$errorMessage <- error_msg
            return()
          }
          
          # Check if viral is NULL
          if (is.null(viral) || length(viral$genes_aa) == 0) {
            print("No valid viral sequences!")
            values$showProcessing <- FALSE
            values$showError <- TRUE
            values$errorMessage <- "No valid outbreak virus sequences found after filtering."
            return()
          }
          
          # Check if serum is NULL
          if (is.null(serum) || length(serum$genes_aa) == 0) {
            print("No valid serum sequences!")
            values$showProcessing <- FALSE
            values$showError <- TRUE
            values$errorMessage <- "No valid vaccine/LVI virus sequences found after filtering."
            return()
          }
          
          print("No errors detected, continuing...")
          
          # Collect warning messages
          print("Collecting warning messages...")
          warning_messages <- c()
          if (!is.null(viral$warning_msg) && nchar(viral$warning_msg) > 0) {
            warning_messages <- c(warning_messages, "OUTBREAK VIRUS SEQUENCES:\n", viral$warning_msg)
          }
          if (!is.null(serum$warning_msg) && nchar(serum$warning_msg) > 0) {
            warning_messages <- c(warning_messages, "VACCINE/LVI VIRUS SEQUENCES:\n", serum$warning_msg)
          }
          
          # Build validation message
          print("Building validation message...")
          initial_validation_msg <- ""
          if (length(warning_messages) > 0) {
            initial_validation_msg <- paste(
              paste(warning_messages, collapse = "\n"),
              "\nProceeding with valid sequences only...\n",
              sep = ""
            )
          } else {
            initial_validation_msg <- "All sequences passed validation.\n"
          }
          initial_validation_msg <- paste0(initial_validation_msg, 
                                           "Valid outbreak sequences: ", length(viral$genes_aa),
                                           "\nValid vaccine/LVI sequences: ", length(serum$genes_aa), "\n")
          values$validationMessage <- initial_validation_msg
          print("Validation message set")
          
          # Extract ORF5 for variant prediction
          print("=== Starting variant prediction ===")
          viral_orf5_nt <- lapply(viral$genes_nt, function(x) x$orf5)
          serum_orf5_nt <- lapply(serum$genes_nt, function(x) x$orf5)
          print(paste("Viral ORF5 sequences:", length(viral_orf5_nt)))
          print(paste("Serum ORF5 sequences:", length(serum_orf5_nt)))
          
          # Predict variants
          print("Predicting viral variants...")
          viral_variants <- tryCatch({
            R.utils::withTimeout(predict_variants(viral_orf5_nt, use_github = TRUE), timeout = 30)
          }, TimeoutException = function(ex) {
            print("Variant prediction timed out, using unclassified")
            setNames(rep("unclassified", length(viral_orf5_nt)), names(viral_orf5_nt))
          }, error = function(e) {
            print(paste("Variant prediction error:", e$message))
            setNames(rep("unclassified", length(viral_orf5_nt)), names(viral_orf5_nt))
          })
          print(paste("Viral variants predicted:", length(viral_variants)))
          
          print("Predicting serum variants...")
          serum_variants <- tryCatch({
            predict_variants(serum_orf5_nt, use_github = (input$inputmode == "both"))
          }, error = function(e) {
            print(paste("Serum variant prediction error:", e$message))
            setNames(rep("unclassified", length(serum_orf5_nt)), names(serum_orf5_nt))
          })
          print(paste("Serum variants predicted:", length(serum_variants)))
          
          # Find all glycosylation sites for each gene
          print("=== Finding glycosylation sites ===")
          all_glyco_sites <- list()
          for (gene_name in names(gene_positions)) {
            gene_glyco <- c()
            for (seq_name in names(viral$genes_aa)) {
              aa_seq <- viral$genes_aa[[seq_name]][[gene_name]]
              seq_vec <- strsplit(aa_seq, "")[[1]]
              # Only consider valid positions
              if (!is.null(viral$valid_positions[[seq_name]][[gene_name]])) {
                valid_pos <- viral$valid_positions[[seq_name]][[gene_name]]
                seq_vec[!valid_pos[1:length(seq_vec)]] <- "-"
              }
              gene_glyco <- c(gene_glyco, find_glyco_sites(seq_vec))
            }
            for (seq_name in names(serum$genes_aa)) {
              aa_seq <- serum$genes_aa[[seq_name]][[gene_name]]
              seq_vec <- strsplit(aa_seq, "")[[1]]
              # Only consider valid positions
              if (!is.null(serum$valid_positions[[seq_name]][[gene_name]])) {
                valid_pos <- serum$valid_positions[[seq_name]][[gene_name]]
                seq_vec[!valid_pos[1:length(seq_vec)]] <- "-"
              }
              gene_glyco <- c(gene_glyco, find_glyco_sites(seq_vec))
            }
            all_glyco_sites[[gene_name]] <- unique(sort(gene_glyco))
            print(paste("  ", gene_name, ":", length(all_glyco_sites[[gene_name]]), "glycosylation sites"))
          }
          
          # Extract features for all pairs
          print("=== Extracting features for all pairs ===")
          feature_rows <- list()
          meta_rows <- list()
          variant_info_rows <- list()
          
          pair_count <- 0
          total_pairs <- length(viral$genes_aa) * length(serum$genes_aa)
          
          for (vi in names(viral$genes_aa)) {
            for (si in names(serum$genes_aa)) {
              pair_count <- pair_count + 1
              print(paste("Processing pair", pair_count, "/", total_pairs, ":", vi, "vs", si))
              
              virus_var <- if(vi %in% names(viral_variants)) viral_variants[[vi]] else "unclassified"
              serum_var <- if(si %in% names(serum_variants)) serum_variants[[si]] else "unclassified"
              
              # Get valid positions for this pair
              virus_valid_pos <- if (!is.null(viral$valid_positions[[vi]])) viral$valid_positions[[vi]] else NULL
              serum_valid_pos <- if (!is.null(serum$valid_positions[[si]])) serum$valid_positions[[si]] else NULL
              
              features <- extract_all_gene_features(
                vi, si,
                viral$genes_aa[[vi]], serum$genes_aa[[si]],
                viral$genes_nt[[vi]], serum$genes_nt[[si]],
                all_glyco_sites,
                viral_variants, serum_variants,
                virus_valid_pos, serum_valid_pos
              )
              
              feature_rows[[paste(vi, si, sep="|")]] <- features
              meta_rows[[paste(vi, si, sep="|")]] <- list(vaccine_LVI_virus=si, outbreak_virus=vi)
              variant_info_rows[[paste(vi, si, sep="|")]] <- list(
                vaccine_LVI_virus=si, 
                outbreak_virus=vi,
                vaccine_LVI_variant=serum_var,
                outbreak_variant=virus_var
              )
            }
          }
          
          print(paste("Feature extraction complete for", pair_count, "pairs"))
          
          variant_info_df <- bind_rows(variant_info_rows)
          feature_df <- bind_cols(bind_rows(meta_rows), bind_rows(feature_rows))
          print(paste("Feature dataframe dimensions:", nrow(feature_df), "x", ncol(feature_df)))
          
          # Track sequence-level imputation for reporting
          viral_imputation <- list()
          serum_imputation <- list()
          
          # Count invalid positions across all genes for viral sequences
          for (seq_name in names(viral$valid_positions)) {
            total_invalid <- 0
            total_positions <- 0
            
            for (gene_name in names(viral$valid_positions[[seq_name]])) {
              valid_pos <- viral$valid_positions[[seq_name]][[gene_name]]
              total_invalid <- total_invalid + sum(!valid_pos)
              total_positions <- total_positions + length(valid_pos)
            }
            
            if (total_invalid > 0) {
              # Estimate affected features (each gene has ~15-20 features per position)
              affected_features <- total_invalid * 15
              
              viral_imputation[[seq_name]] <- list(
                invalid_count = total_invalid,
                coverage = (total_positions - total_invalid) / total_positions,
                affected_features = affected_features
              )
            }
          }
          
          # Count invalid positions for serum sequences (skip built-in vaccines if using them)
          if (input$inputmode == "both") {
            for (seq_name in names(serum$valid_positions)) {
              total_invalid <- 0
              total_positions <- 0
              
              for (gene_name in names(serum$valid_positions[[seq_name]])) {
                valid_pos <- serum$valid_positions[[seq_name]][[gene_name]]
                total_invalid <- total_invalid + sum(!valid_pos)
                total_positions <- total_positions + length(valid_pos)
              }
              
              if (total_invalid > 0) {
                affected_features <- total_invalid * 15
                
                serum_imputation[[seq_name]] <- list(
                  invalid_count = total_invalid,
                  coverage = (total_positions - total_invalid) / total_positions,
                  affected_features = affected_features
                )
              }
            }
          }
          
          print("=== Sequence-level Imputation Summary ===")
          print(paste("Viral sequences with imputation:", length(viral_imputation)))
          print(paste("Serum sequences with imputation:", length(serum_imputation)))
          
          # Load LightGBM model
          print("=== Loading LightGBM model ===")
          lightgbm_model <- load_lightgbm_model(lightgbm_mg_model_path)
          print("Model loaded successfully")
          
          # Load features with median values for imputation
          print("Loading feature medians for imputation...")
          lgb_features_df <- read.csv(lightgbm_mg_features_path, stringsAsFactors = FALSE)
          lgb_features <- lgb_features_df$feature
          median_values <- setNames(lgb_features_df$median, lgb_features_df$feature)
          print(paste("Loaded", length(lgb_features), "features with median values"))
          
          # Prepare features for LightGBM - impute with median
          print("=== Preparing features with median imputation ===")
          
          lgb_missing_feats <- setdiff(lgb_features, colnames(feature_df))
          if (length(lgb_missing_feats) > 0) {
            print(paste("LightGBM Model: Imputing", length(lgb_missing_feats), "missing features with median values"))
            for (f in lgb_missing_feats) {
              if (f %in% names(median_values)) {
                feature_df[[f]] <- median_values[[f]]
              } else {
                feature_df[[f]] <- 0
              }
            }
            # Print first 20 missing features as example
            if (length(lgb_missing_feats) > 20) {
              print(paste("First 20 missing features:", paste(lgb_missing_feats[1:20], collapse = ", "), "..."))
            } else {
              print(paste("Missing features imputed:", paste(lgb_missing_feats, collapse = ", ")))
            }
          }
          
          lgb_feature_df <- feature_df[, lgb_features, drop = FALSE]
          
          # Replace NA with median values and track by row
          na_imputation_count <- 0
          for (col in colnames(lgb_feature_df)) {
            na_idx <- which(is.na(lgb_feature_df[[col]]))
            if (length(na_idx) > 0) {
              if (col %in% names(median_values)) {
                lgb_feature_df[[col]][na_idx] <- median_values[[col]]
                # Print first few imputations per column
                for (row_idx in na_idx[1:min(3, length(na_idx))]) {
                  pair_name <- paste0(feature_df$outbreak_virus[row_idx], " vs ", feature_df$vaccine_LVI_virus[row_idx])
                  print(paste("LightGBM - Imputing NA for feature '", col, "' in pair '", pair_name, "' with median:", round(median_values[[col]], 4)))
                }
                if (length(na_idx) > 3) {
                  print(paste("  ... and", length(na_idx) - 3, "more NA values for", col))
                }
              } else {
                lgb_feature_df[[col]][na_idx] <- 0
                for (row_idx in na_idx[1:min(3, length(na_idx))]) {
                  pair_name <- paste0(feature_df$outbreak_virus[row_idx], " vs ", feature_df$vaccine_LVI_virus[row_idx])
                  print(paste("LightGBM - Imputing NA for feature '", col, "' in pair '", pair_name, "' with 0 (no median available)"))
                }
              }
              na_imputation_count <- na_imputation_count + length(na_idx)
            }
          }
          
          # Summary of imputation
          print("=== Imputation Summary ===")
          print(paste("Total missing feature columns imputed:", length(lgb_missing_feats)))
          print(paste("Total NA values imputed:", na_imputation_count))
          
          # Predictions
          print("=== Making predictions ===")
          lgb_matrix <- as.matrix(lgb_feature_df)
          print(paste("Prediction matrix dimensions:", nrow(lgb_matrix), "x", ncol(lgb_matrix)))
          
          lgb_raw_preds <- predict(lightgbm_model, lgb_matrix)
          lgb_probs_high <- lgb_raw_preds
          lgb_probs_low <- 1 - lgb_raw_preds
          lgb_preds <- ifelse(lgb_raw_preds > 0.5, "high", "low")
          print(paste("Predictions complete:", sum(lgb_preds == "high"), "high,", sum(lgb_preds == "low"), "low"))
          
          # Build prediction table
          print("Building prediction table...")
          pred_table <- feature_df[,c("vaccine_LVI_virus","outbreak_virus")]
          pred_table[["Neutralizing Titer Prediction"]] <- lgb_preds
          pred_table[["Prediction Probability"]] <- ifelse(lgb_preds == "high",
                                                           round(lgb_probs_high, 3),
                                                           round(lgb_probs_low, 3))
          
          pred_table <- merge(pred_table, variant_info_df, by = c("vaccine_LVI_virus", "outbreak_virus"), all.x = TRUE)
          values$predictionTable <- pred_table
          print(paste("Prediction table created with", nrow(pred_table), "rows"))
          
          # Success - build detailed validation message
          print("=== MULTI-GENE PREDICTION COMPLETE ===")
          values$showProcessing <- FALSE
          values$showError <- FALSE
          values$showResults <- TRUE
          
          # Build imputation summary message
          if (length(viral_imputation) > 0 || length(serum_imputation) > 0) {
            imputation_msg <- "\n=== Imputation Summary ===\n"
            imputation_msg <- paste0(imputation_msg, 
                                     format_imputation_summary(viral_imputation, "Outbreak Virus"))
            imputation_msg <- paste0(imputation_msg, 
                                     format_imputation_summary(serum_imputation, "Vaccine/LVI Virus"))
            
            total_imputed <- length(viral_imputation) + length(serum_imputation)
            imputation_msg <- paste0(imputation_msg, 
                                     "\nTotal: ", total_imputed, " sequence(s) had features imputed due to invalid/ambiguous nucleotides.\n",
                                     "Note: Invalid positions were replaced with median values from internal cross-neutralization data.\n")
            
            values$validationMessage <- paste0(initial_validation_msg, 
                                               "Prediction completed successfully.\n", 
                                               imputation_msg)
          } else {
            values$validationMessage <- paste0(initial_validation_msg, 
                                               "All sequences passed validation with no imputation needed. Prediction completed successfully.")
          }
          
          output$summary_table <- DT::renderDataTable({ 
            values$predictionTable
          }, options = list(
            paging = FALSE,
            ordering = TRUE,
            scrollY = "400px",
            scrollX = TRUE,
            columnDefs = list(
              list(className = 'dt-center', targets = "_all"),
              list(render = JS("function(data, type, row) {
                return type === 'display' && data != null ? Number(data).toFixed(3) : data;
              }"), targets = 3)
            )
          ), rownames = FALSE, class = 'cell-border stripe')
        }
        
        # Common download handler for summary table
        output$downloadSummary <- downloadHandler(
          filename = function() { paste("neutralization_summary_", Sys.Date(), ".csv", sep="") },
          content = function(file) { 
            if (!is.null(values$predictionTable)) {
              write.csv(values$predictionTable, file, row.names=FALSE) 
            }
          }
        )
        
      }, error = function(e) {
        values$showProcessing <- FALSE
        values$showError <- TRUE
        values$showResults <- FALSE
        values$errorMessage <- "Please check your sequencing data to ensure they follow the input file requirements described in the upper panel."
      })
    })
  })
  
  # Download log handler - OUTSIDE observeEvent so it's always available
  output$downloadLog <- downloadHandler(
    filename = function() {
      paste0("XRpred_console_log_", Sys.Date(), ".txt")
    },
    content = function(file) {
      # Flush the connection if possible, then copy the current log file
      src <- session$userData$xrpred_log_file
      if (is.null(src) || !file.exists(src)) {
        writeLines("No log file available.", con = file)
      } else {
        # attempt to flush
        try({
          if (!is.null(session$userData$xrpred_log_con)) flush(session$userData$xrpred_log_con)
        }, silent = TRUE)
        # Copy current log contents to the download file
        file.copy(src, file, overwrite = TRUE)
      }
    }
  )
}

shinyApp(ui, server)
